{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Using Xilinx Alveo FPGAs as SmartNICs with ESnet Framework Video tutorial available here: Youtube Link Table of Contents Introduction Prerequisites Copyright Notice Operator's Guide to Configuring an Alveo Host Lesson 1: Overview Lesson 2: The Development Workflow Lesson 3: The Deployment Workflow Lesson 4: Running the Deployment Introduction Welcome to the tutorial on utilizing Xilinx Alveo FPGAs as SmartNICs within the ESnet framework. In this tutorial, we'll guide you through the process of setting up, configuring, and utilizing the power of Xilinx Alveo FPGAs for network acceleration using the ESnet framework. Prerequisites Before you begin, this tutorial assumes that you have access to a pre-configured system that has already been tested for development and deployment using the ESnet framework. If you are a student taking CS 595 at IIT in Fall 2023, Airfield would be your pre-configured system. Please note that everything mentioned in this tutorial has been tested on Airfield. Please make sure you have the following (if you are taking CS 595 you can ignor this step): Basic understanding of FPGA programming and networking concepts Xilinx Vivado 2023.1 A valid VitisNetworkingP4 license For operators/administrators: If you are seeking configuring your system is to is compatible with the ESnet SmartNIC framework, please see: Operator's Guide to Configuring an Alveo Host Copyright Notice ESnet SmartNIC Copyright (c) 2022, The Regents of the University of California, through Lawrence Berkeley National Laboratory (subject to receipt of any required approvals from the U.S. Dept. of Energy), 12574861 Canada Inc., Malleable Networks Inc., and Apical Networks, Inc. All rights reserved. If you have questions about your rights to use or distribute this software, please contact Berkeley Lab's Intellectual Property Office at IPO@lbl.gov. NOTICE. This Software was developed under funding from the U.S. Department of Energy and the U.S. Government consequently retains certain rights. As such, the U.S. Government has been granted for itself and others acting on its behalf a paid-up, nonexclusive, irrevocable, worldwide license in the Software to reproduce, distribute copies to the public, prepare derivative works, and perform publicly and display publicly, and to permit others to do so. For more information: ESnet's License Getting Started Get started with lesson 1: Lesson 1: Overview Happy networking!","title":"Intro"},{"location":"#using-xilinx-alveo-fpgas-as-smartnics-with-esnet-framework","text":"","title":"Using Xilinx Alveo FPGAs as SmartNICs with ESnet Framework"},{"location":"#video-tutorial-available-here-youtube-link","text":"","title":"Video tutorial available here: Youtube Link"},{"location":"#table-of-contents","text":"Introduction Prerequisites Copyright Notice Operator's Guide to Configuring an Alveo Host Lesson 1: Overview Lesson 2: The Development Workflow Lesson 3: The Deployment Workflow Lesson 4: Running the Deployment","title":"Table of Contents"},{"location":"#introduction","text":"Welcome to the tutorial on utilizing Xilinx Alveo FPGAs as SmartNICs within the ESnet framework. In this tutorial, we'll guide you through the process of setting up, configuring, and utilizing the power of Xilinx Alveo FPGAs for network acceleration using the ESnet framework.","title":"Introduction"},{"location":"#prerequisites","text":"Before you begin, this tutorial assumes that you have access to a pre-configured system that has already been tested for development and deployment using the ESnet framework. If you are a student taking CS 595 at IIT in Fall 2023, Airfield would be your pre-configured system. Please note that everything mentioned in this tutorial has been tested on Airfield. Please make sure you have the following (if you are taking CS 595 you can ignor this step): Basic understanding of FPGA programming and networking concepts Xilinx Vivado 2023.1 A valid VitisNetworkingP4 license For operators/administrators: If you are seeking configuring your system is to is compatible with the ESnet SmartNIC framework, please see: Operator's Guide to Configuring an Alveo Host","title":"Prerequisites"},{"location":"#copyright-notice","text":"ESnet SmartNIC Copyright (c) 2022, The Regents of the University of California, through Lawrence Berkeley National Laboratory (subject to receipt of any required approvals from the U.S. Dept. of Energy), 12574861 Canada Inc., Malleable Networks Inc., and Apical Networks, Inc. All rights reserved. If you have questions about your rights to use or distribute this software, please contact Berkeley Lab's Intellectual Property Office at IPO@lbl.gov. NOTICE. This Software was developed under funding from the U.S. Department of Energy and the U.S. Government consequently retains certain rights. As such, the U.S. Government has been granted for itself and others acting on its behalf a paid-up, nonexclusive, irrevocable, worldwide license in the Software to reproduce, distribute copies to the public, prepare derivative works, and perform publicly and display publicly, and to permit others to do so. For more information: ESnet's License","title":"Copyright Notice"},{"location":"#getting-started","text":"Get started with lesson 1: Lesson 1: Overview Happy networking!","title":"Getting Started"},{"location":"1-lesson1/","text":"Lesson 1: Overview The ESnet SmartNIC framework provides an entire workflow to program AMD/Xilinx Alveo FPGA cards using P4. The ESnet framework is open-source and available on GitHub. ESnet is a high-performance network that supports scientific research. The ESnet team created the framework that seamlessly integrates AMD/Xilinx tools along with various tools like DPDK to provide an easy way of programming Alveo cards as SmartNICs. To program Alveo cards with P4 and deploy your applications effectively, we will divide the process into two main workflows: Development Workflow: This phase involves compiling your P4 programs into bitfiles. It necessitates the use of licensed tools from Xilinx and access to an FPGA. Experimenters have the option to either join the XUP (Xilinx/AMD University Program) to request the required tool licenses and FPGA hardware or utilize one of the available facilities that offer access, which can be found in the following reference (provided by the good folks of FABRIC): Access to FPGA Resources (https://learn.fabric-testbed.net/knowledge-base/using-xilinx-u280-fpgas-on-fabric/) Deployment Workflow: This stage requires Alveo cards, enabling you to load your generated bitfiles onto the cards for experimental purposes. By following these two workflows, you can efficiently program and deploy Alveo FPGA cards as SmartNICs, making them integral to your high-performance network infrastructure. References This tutorial is built on the following software/respositories along with versions/commits: Ubuntu 20.04 with Linux 5.4.0-153. Vivado 2023.1 with the VitisNetowrkingP4 license. The esnet-smartnic-hw repository (commit: 9ee2cbb). The esnet-smartnic-fw repository (commit: 180595c). The smartnic-dpdk-docker repository (commit: a52dba3). The xilinx-labtools-docker repository (commit: 84cf05f). Known Issues None to date. If you face any issues, please contact mailto:cs595-f2023-group@iit.edu Lesson 2: The Development Workflow Link: Lesson 2: The Development Workflow","title":"Lesson 1"},{"location":"1-lesson1/#lesson-1-overview","text":"The ESnet SmartNIC framework provides an entire workflow to program AMD/Xilinx Alveo FPGA cards using P4. The ESnet framework is open-source and available on GitHub. ESnet is a high-performance network that supports scientific research. The ESnet team created the framework that seamlessly integrates AMD/Xilinx tools along with various tools like DPDK to provide an easy way of programming Alveo cards as SmartNICs. To program Alveo cards with P4 and deploy your applications effectively, we will divide the process into two main workflows: Development Workflow: This phase involves compiling your P4 programs into bitfiles. It necessitates the use of licensed tools from Xilinx and access to an FPGA. Experimenters have the option to either join the XUP (Xilinx/AMD University Program) to request the required tool licenses and FPGA hardware or utilize one of the available facilities that offer access, which can be found in the following reference (provided by the good folks of FABRIC): Access to FPGA Resources (https://learn.fabric-testbed.net/knowledge-base/using-xilinx-u280-fpgas-on-fabric/) Deployment Workflow: This stage requires Alveo cards, enabling you to load your generated bitfiles onto the cards for experimental purposes. By following these two workflows, you can efficiently program and deploy Alveo FPGA cards as SmartNICs, making them integral to your high-performance network infrastructure.","title":"Lesson 1: Overview"},{"location":"1-lesson1/#references","text":"This tutorial is built on the following software/respositories along with versions/commits: Ubuntu 20.04 with Linux 5.4.0-153. Vivado 2023.1 with the VitisNetowrkingP4 license. The esnet-smartnic-hw repository (commit: 9ee2cbb). The esnet-smartnic-fw repository (commit: 180595c). The smartnic-dpdk-docker repository (commit: a52dba3). The xilinx-labtools-docker repository (commit: 84cf05f).","title":"References"},{"location":"1-lesson1/#known-issues","text":"None to date. If you face any issues, please contact mailto:cs595-f2023-group@iit.edu","title":"Known Issues"},{"location":"1-lesson1/#lesson-2-the-development-workflow","text":"Link: Lesson 2: The Development Workflow","title":"Lesson 2: The Development Workflow"},{"location":"2-lesson2/","text":"Lesson 2: The Development Workflow Welcome to Lesson 2 of our tutorial series on utilizing Xilinx Alveo FPGAs as SmartNICs within the ESnet framework. This step involves writing the P4 applications, testing, debugging, and compiling them to bitfiles that can be run on the AMD/Xilinx Alveo cards. This step makes use of Vivado and VitisNetworkingP4 to provide all the tools needed for your P4 development. The ESnet framework streamlines your P4 development with readily available scripts and makefiles. These resources ensure that you can seamlessly test and compile your P4 logic into bitfiles, allowing you to focus exclusively on your P4 programming. As mentioned above, this step requires special licensing. If you already possess the bitfiles ready for deployment onto the U280 cards, you may proceed directly to the \"Deployment Workflow\" section. Introduction: The tools required to be able to write, test, simulate and compile P4 programs written for the Xilinx Alveo FPGAs are based on (and included) in the esnet-smartnic-hw repository. Repository Structure and Dependencies The ESnet SmartNIC platform is comprised of a collection of separate modular components, each maintained in their own git repository. The platform includes the following repositories: OpenNIC shell (https://github.com/esnet/open-nic-shell.git) An FPGA-based NIC shell that runs on the AMD (Xilinx) Alveo family of hardware boards. This repository is a fork of a Xilinx-provided repository (https://github.com/Xilinx/open-nic-shell.git). This repository also includes customizations for the ESnet SmartNIC platform. ESnet SmartNIC Hardware (https://github.com/esnet/esnet-smartnic-hw.git) Hardware design directory for the ESnet SmartNIC platform. ESnet SmartNIC Firmware (https://github.com/esnet/esnet-smartnic-fw.git) Firmware design directory for the ESnet SmartNIC platform. ESnet FPGA library (https://github.com/esnet/esnet-fpga-library.git) General-purpose components and infrastructure for a structured FPGA design methodology. SVunit (https://github.com/svunit/svunit.git) An open-source framework for FPGA System Verilog verification. SVunit is used by the SmartNIC platform, but is neither maintained nor distributed by ESnet. ESnet Regio (https://github.com/esnet/regio.git) Automation tools for the implementation of FPGA register map logic and software code. All dependent repositories are instantiated in the parent repository as a submodule, as depicted below: esnet-smartnic-hw/ (parent repository) \u251c\u2500\u2500 esnet-fpga-library/ (submodule) \u2502 \u2514\u2500\u2500 tools/ \u2502 \u251c\u2500\u2500 regio/ (submodule) \u2502 \u2514\u2500\u2500 svunit/ (submodule) \u2514\u2500\u2500 open-nic-shell/ (submodule) esnet-smartnic-fw/ (parent repository) Directory Structure The directory structure for the ESnet SmartNIC hardware design repository is captured and described below. esnet-smartnic-hw/ \u251c\u2500\u2500 cfg/ \u251c\u2500\u2500 config.mk \u251c\u2500\u2500 docs/ \u251c\u2500\u2500 esnet-fpga-library/ \u251c\u2500\u2500 examples/ \u251c\u2500\u2500 LICENSE.md \u251c\u2500\u2500 Makefile \u251c\u2500\u2500 makefile.esnet \u251c\u2500\u2500 open-nic-shell/ \u251c\u2500\u2500 paths.mk \u251c\u2500\u2500 README.md \u251c\u2500\u2500 scripts/ \u2514\u2500\u2500 src/ cfg/ Contains global configuration files for the SmartNIC project. config.mk Sets environment variables for the SmartNIC project. docs/ Contains documentation files for the SmartNIC platform. esnet-fpga-library/ Contains the ESnet FPGA Design Library (imported as a git submodule). This library contains general-purpose FPGA design content. examples/ Contains SmartNIC application design exaples. A new application directory can be started by copying one of the provided example directories, or by modeling portions of the example directory structure. LICENSE.md Contains the licensing terms and copyright notice for this repository. Makefile SmartNIC platform Makefile. Used to build the FPGA bitfile for the target application, as well as generate all artifacts necessary for firmware integration on the hardware platform. makefile.esnet OpenNIC shell Makefile. Used to build the AMD (Xilinx) open-nic-shell for the target application. open-nic_shell/ Contains the AMD (Xilinx) OpenNIC Shell repository (imported as a git submodule). OpenNIC shell delivers an FPGA-based NIC shell with 100Gbps Ethernet ports, for use on the AMD (Xilinx) Alveo platform. paths.mk Describes paths to resources provided by the SmartNIC project. README.md This README file. scripts/ Contains SmartNIC platform scripts, for application configuration. src/ Contains RTL source and verification code for SmartNIC platform FPGA design components, captured in System Verilog. Installing the SmartNIC Hardware Design Repository The following steps guide a new user through the installation of the SmartNIC Hardware Design Repository, beginning with a suitably-configured host running Ubuntu 20.04 LTS Linux. Install the esnet-smartnic-hw respository by creating a clone from github into a local directory: git clone https://github.com/esnet/esnet-smartnic-hw.git Initialize all submodules within the esnet-smartnic-hw/ design directory: cd esnet-smartnic-hw git submodule update --init --recursive Install the prerequisites required to run the esnet regio tools: sudo apt install python3-yaml python3-jinja2 python3-click pip3 install -r esnet-fpga-library/tools/regio/requirements.txt Note: The above instructions and more details about the regio tools can be found in the README file at: esnet-fpga-library/tools/regio/README.md Building the SmartNIC p4_only Example Design You can build the p4_only example design by executing its Makefile. Follow these steps: Navigate to the p4_only example design directory: ```shell cd examples/p4_only ``` Modify the Makefile to ensure that export BOARD is set to the target card (i.e au280 or au55c): ```shell export BOARD := au280 ``` Make sure to source the Vivado environment script: ```shell source /tools/Xilinx/Vivado/2023.1/settings.64.sh ``` At the time of writing this guide, 2023.1 was the version supported by the ESnet framework. Please refer to the README on the ESnet repositories. Run the Makefile to build the design: ```shell make ``` Upon completion, you'll find an artifact zipfile with the default pathname: artifacts/<BUILD_NAME>/artifacts.<BOARD>.<BUILD_NAME>.0.zip . This artifact zipfile contains all necessary hardware artifacts, including the bitfile, firmware driver files, regmap YAML files, the source P4 file, and any Wireshark .lua files. For more details about the p4_only design and simulating the P4 program, refer to the examples/p4_only/README.md file. You can find more information on the ESnet development workflow here: ESnet Development Workflow . Building a New P4 Application The following steps can be taken by a new user to setup a local application design directory for building the bitfile and artifacts for a custom P4-based SmartNIC application. Install the esnet-smartnic-hw respository (as described above). Or, alternatively, add the esnet-smartnic-hw respository to an existing git repository as a sub-module: > git submodule add https://github.com/esnet/esnet-smartnic-hw.git Initialize all submodules within the esnet-smartnic-hw/ design directory: cd esnet-smartnic-hw git submodule update --init --recursive Install Vivado and configure the runtime environment (as described above). Return to the local application design directory and then copy the example SmartNIC application Makefile and p4/ sub-directory into the local application design directory: cd ../ cp esnet-smartnic-hw/examples/p4_only/Makefile ./ cp -r esnet-smartnic-hw/examples/p4_only/p4 ./ Using a preferred editor, edit the copied Makefile to update the SMARTNIC_DIR environment variable assignment as follows: #SMARTNIC_DIR := ../.. SMARTNIC_DIR := $(CURDIR)/esnet-smartnic-hw Copy the application p4 file to the following location and filename: cp p4/ basename $PWD .p4 Note: By default, the SmartNIC scripts take the basename of the application design directory to be the name of the application, as well as its associated filenames. Make sure to source the Vivado environment script: ```shell source /tools/Xilinx/Vivado/2023.1/settings.64.sh ``` At the time of writing this guide, 2023.1 was the version supported by the ESnet framework. Please refer to the README on the ESnet repositories. Build the design by executing the copied application Makefile: make To simulate the P4 program, refer to the readme file provided in the p4/sim/ directory i.e. p4/sim/README.md P4 Programming Requirements The P4 processing core of the SmartNIC platform is implemented with the AMD (Xilinx) VitisNetP4 IP core. In order to meet the requirements of the VitisNetP4 IP core and the SmartNIC platform, a new P4 program should consider the following guidelines. AMD (Xilinx) P4 Architecture: The Vitis Networking P4 compiler supports a specific pipelined datapath architecture that is comprised of 3 customizable stages: A Parser Engine, followed by a Match-Action Engine, followed by a Deparser Engine. User P4 files MUST be structured to comply with this processing architecture, and specify the custom operations desired within each of these processing stages. More details about the AMD (Xilinx) P4 architecture can be found in the Vitis Networking P4 User Guide, UG1308 (v2023.1) May 16, 2023 . Include files: The P4 program MUST include the following AMD (Xilinx) VitisNetP4 include files: #include <core.p4> #include <xsa.p4> These files capture built-in constructs and the standard definitions for the AMD (Xilinx) P4 architecture. They are located in the Vivado installation directory at: $XILINX_VIVADO/data/ip/xilinx/vitis_net_p4_v1_1/include/p4/ Interfaces: The P4 processing core supports 3 types of interfaces: Packet Ports are the primary interfaces responsible for moving packets in and out of the core, as well as between engines. Engines can only contain a single input packet port and a single output packet port. Metadata Ports carry sideband data related to a packet. Metadata can only correspond to a single packet and is processed in parallel with the packet. More on Metadata below. Register IO Ports (axi4l) are used to control the contents of the Look-up engines. Metadata Definitions: The VitisNetP4 core supports both Standard Metadata (defined and set by the P4 core), and User Metadata (defined and set by the SmartNIC platform). Both types of metadata can be read and/or written by the P4 program. For more details about the Standard Metadata definitions, see Vitis Networking P4 User Guide, UG1308 (v2023.1) May 16, 2023 . In order for the compiled VitisNetP4 core to match the SmartNIC application interface, a user P4 program MUST define the User Metadata structure as follows: struct smartnic_metadata { bit<64> timestamp_ns; // 64b timestamp (in nanoseconds). Set at packet arrival time. bit<16> pid; // 16b packet id used by platform (READ ONLY - DO NOT EDIT). bit<3> ingress_port; // 3b ingress port (0:CMAC0, 1:CMAC1, 2:HOST0, 3:HOST1). bit<3> egress_port; // 3b egress port (0:CMAC0, 1:CMAC1, 2:HOST0, 3:HOST1). bit<1> truncate_enable; // reserved (tied to 0). bit<16> truncate_length; // reserved (tied to 0). bit<1> rss_enable; // reserved (tied to 0). bit<12> rss_entropy; // reserved (tied to 0). bit<4> drop_reason; // reserved (tied to 0). bit<32> scratch; // reserved (tied to 0). } Lookup Engines and Externs: In order for the compiled VitisNetP4 core to match the SmartNIC application interface, a user Program MUST have: One (or more) Look-up Engines. No HBM BCAMs. No Externs. Support for these features may be added in a future release. The tl;dr You can simply do: cd examples/p4_only/p4 and here you can modify the p4 program. If you run make it will compile your P4 program into the Xilinx FPGA board model specified in Makefile . P4 Simulation: p4_only The p4_only example design provides the P4 source code and a behavioural simulation testcase for a simple P4 application core. This example follows a pure P4 design flow and does NOT include any custom verilog hardware. As such, the user only provides the working P4 program file to build the custom SmartNIC hardware. Functional Specification The p4_only design implements a simple table-based Layer-2 packet switch. It uses a single LPM lookup table that takes the Ethernet Destination MAC Address field as the key. When the lookup matches, the table returns the programmed destination port for the specified packet flow. The returned destination port is then written into the output metadata ( egress_port field), which is used by the SmartNIC hardware for packet forwarding. When the lookup misses, the output metadata remains unchanged and the packet is forwarded to the destination port that was specified in the packet's input metadata ( egress_port field). Packets with invalid and errored Ethernet headers are dropped. Makefile The execution of P4 behavioural simulations is driven by the Makefile in the p4/sim/ directory. This Makefile includes the variable assignments that specify how to run a p4 behavioural simulation, as well as the name of the p4 file and list of testcases that should be included in a full simulation run. Each testcase is captured in a separate subdirectory, which contains the input and output files for the specified test. The testcase subdirectories follow the naming pattern of test-<NAME> . Prior to running a simulation, the user should update the Makefile with the following variable assignments (all other variable assignments can remain unchanged): P4_SOURCE = <pathname of p4 source file> P4BM_DIRS = <testcase subdirectory list> The Makefile includes execution targets to run (or clean) a single testcase simulation, or simulation of the full testcase suite. To simulate a single testcase, execute make with the P4BM_DIR= argument set to the testcase subdirectory of interest. For example: > make P4BM_DIR=test-fwd-p0 Or to simulate all test cases: > make sim-all Note: the sim-all target is the default target when make is called without arguments. To clean all simulation output products from the p4 directory, type: > make clean Terminal Configuration If you encounter the following warning when using rlwrap: rlwrap: warning: your $TERM is 'xterm-256color' but rlwrap couldn't find it in the terminfo database. Expect some problems. You can resolve this issue by adding the following line to your .profile file: export TERM=xterm1 Testcase Input Files The input stimulus file set for each testcase includes three files: cli_commands.txt - Command script to set table entries and initiate input stimulus. Commands and syntax follow the Xilinx p4bm-vitisnet-cli. packets_in.user - Input packet stream user data. Each byte sequence terminated by a semicolon (;) represents a packet. Packets are captured in sequence. The '%' character is used to start comments. packets_in.pcap - PCAP file containing the input packet stream. Alternative format to packets_in.user (optional). packets_in.meta - Input packet metadata. Each line corresponds to a packet in the input PCAP file (in sequence). The syntax of the metadata is described in the Xilinx VitisnetP4 documentation. Note: Each metadata record must be terminated by a semicolon (;). For more details, see chapter 3 of Vitis Networking P4 User Guide, UG1308 (v2023.1) May 16, 2023 . Testcase Output Files packets_out.user - Output packet stream user data. Same syntax as input packet stream user data. packets_out.pcap - PCAP file containing the output packet stream, if packets_in format was packets_in.pcap . packets_out.meta - Output packet metadata. Each line corresponds to a packet in the output PCAP file (in sequence). Same syntax as input packet metadata. Note: An expected/ directory is optionally included to capture the expected output results of a testcase. This expected output can be used for automated regression testing. Testcases: p4_only test-fwd-p0 - The p4_only design includes a single example testcase called test-fwd-p0. This testcase programs a small number of table entries that forward the specified packet flows to destination port 0. The input stimulus includes a single packet on each flow to validate that all packets are forwarded to port 0. All other packets are forwarded to the egress_port specified by the input meta data. Generating and Simulating the AMD (Xilinx) Vitisnetp4 Example Design Prior to generating the AMD (Xilinx) vitisnetp4 example design, a user must specify the p4bm test directory that will be imported for simulation. This is done by assigning the full directory pathname to the EXAMPLE_TEST_DIR variable in the application Makefile. For example: export EXAMPLE_TEST_DIR := $(CURDIR)/p4/sim/test-fwd-p0 By setting the above Makefile variable, the example design will import all input stimulus, CLI programming, and any (optional) extern behvioural models associated with the specified simulation testcase. The AMD (Xilinx) vitisnetp4 example design can be generated in the local application design directory by running the 'example' target of the root-level application Makefile, as follows: make example Executing the above make command will generate the vitisnetp4 example design in a subdirectory called example/sdnet_0_ex/ . From the example/sdnet_0_ex/ subdirectory, the AMD (Xilinx) Vivado tool can be invoked, the example design project can be opened, and the p4 processor can be simulated, as follows: cd example/sdnet_0_ex vivado From the File->Project->Open... menu, select 'sdnet_0_ex.xpr' and open the example design project. From the Flow Navigator menu, select 'Simulation->Run Simulation->Run Behavioural Simulation'. For more information about how to simulate designs and evaluate results within the AMD (Xilinx) Vivado GUI, refer to the following document: Vivado Design Suite User Guide - Logic Simulation, UG900 (v2023.1) May 10, 2023. Note that vitisnetp4 example design generation supports the optional instantiation of custom user extern function(s) by including the following design files: System Verilog RTL code for custom extern function(s) in the file extern/rtl/smartnic_extern.sv . Furthermore, if a user captures extern function(s) in a design hierarchy comprised of multiple .sv files, all of the .sv files located in the extern/rtl directory will be included in the example design project, C++ behavioural model(s) for custom extern function(s) in the file p4/sim/user_externs/smartnic_extern.cpp Furthermore, when simulating the vitisnetp4 example design with a user extern, the smartnic_extern instantiation is located within the example_dut_wrapper module (instance name dut_inst/smartnic_extern_0 ). References This tutorial is built on the following software/respositories along with versions/commits: Ubuntu 20.04 with Linux 5.4.0-153. Vivado 2023.1 with the VitisNetowrkingP4 license. The esnet-smartnic-hw repository (commit: 9ee2cbb). The esnet-smartnic-fw repository (commit: 180595c). The smartnic-dpdk-docker repository (commit: a52dba3). The xilinx-labtools-docker repository (commit: 84cf05f). Known Issues None to date. If you face any issues, please contact mailto:cs595-f2023-group@iit.edu Lesson 3: The Deployment Workflow Link: Lesson 3: The Deployment Workflow","title":"Lesson 2"},{"location":"2-lesson2/#lesson-2-the-development-workflow","text":"Welcome to Lesson 2 of our tutorial series on utilizing Xilinx Alveo FPGAs as SmartNICs within the ESnet framework. This step involves writing the P4 applications, testing, debugging, and compiling them to bitfiles that can be run on the AMD/Xilinx Alveo cards. This step makes use of Vivado and VitisNetworkingP4 to provide all the tools needed for your P4 development. The ESnet framework streamlines your P4 development with readily available scripts and makefiles. These resources ensure that you can seamlessly test and compile your P4 logic into bitfiles, allowing you to focus exclusively on your P4 programming. As mentioned above, this step requires special licensing. If you already possess the bitfiles ready for deployment onto the U280 cards, you may proceed directly to the \"Deployment Workflow\" section.","title":"Lesson 2: The Development Workflow"},{"location":"2-lesson2/#introduction","text":"The tools required to be able to write, test, simulate and compile P4 programs written for the Xilinx Alveo FPGAs are based on (and included) in the esnet-smartnic-hw repository.","title":"Introduction:"},{"location":"2-lesson2/#repository-structure-and-dependencies","text":"The ESnet SmartNIC platform is comprised of a collection of separate modular components, each maintained in their own git repository. The platform includes the following repositories: OpenNIC shell (https://github.com/esnet/open-nic-shell.git) An FPGA-based NIC shell that runs on the AMD (Xilinx) Alveo family of hardware boards. This repository is a fork of a Xilinx-provided repository (https://github.com/Xilinx/open-nic-shell.git). This repository also includes customizations for the ESnet SmartNIC platform. ESnet SmartNIC Hardware (https://github.com/esnet/esnet-smartnic-hw.git) Hardware design directory for the ESnet SmartNIC platform. ESnet SmartNIC Firmware (https://github.com/esnet/esnet-smartnic-fw.git) Firmware design directory for the ESnet SmartNIC platform. ESnet FPGA library (https://github.com/esnet/esnet-fpga-library.git) General-purpose components and infrastructure for a structured FPGA design methodology. SVunit (https://github.com/svunit/svunit.git) An open-source framework for FPGA System Verilog verification. SVunit is used by the SmartNIC platform, but is neither maintained nor distributed by ESnet. ESnet Regio (https://github.com/esnet/regio.git) Automation tools for the implementation of FPGA register map logic and software code. All dependent repositories are instantiated in the parent repository as a submodule, as depicted below: esnet-smartnic-hw/ (parent repository) \u251c\u2500\u2500 esnet-fpga-library/ (submodule) \u2502 \u2514\u2500\u2500 tools/ \u2502 \u251c\u2500\u2500 regio/ (submodule) \u2502 \u2514\u2500\u2500 svunit/ (submodule) \u2514\u2500\u2500 open-nic-shell/ (submodule) esnet-smartnic-fw/ (parent repository)","title":"Repository Structure and Dependencies"},{"location":"2-lesson2/#directory-structure","text":"The directory structure for the ESnet SmartNIC hardware design repository is captured and described below. esnet-smartnic-hw/ \u251c\u2500\u2500 cfg/ \u251c\u2500\u2500 config.mk \u251c\u2500\u2500 docs/ \u251c\u2500\u2500 esnet-fpga-library/ \u251c\u2500\u2500 examples/ \u251c\u2500\u2500 LICENSE.md \u251c\u2500\u2500 Makefile \u251c\u2500\u2500 makefile.esnet \u251c\u2500\u2500 open-nic-shell/ \u251c\u2500\u2500 paths.mk \u251c\u2500\u2500 README.md \u251c\u2500\u2500 scripts/ \u2514\u2500\u2500 src/ cfg/ Contains global configuration files for the SmartNIC project. config.mk Sets environment variables for the SmartNIC project. docs/ Contains documentation files for the SmartNIC platform. esnet-fpga-library/ Contains the ESnet FPGA Design Library (imported as a git submodule). This library contains general-purpose FPGA design content. examples/ Contains SmartNIC application design exaples. A new application directory can be started by copying one of the provided example directories, or by modeling portions of the example directory structure. LICENSE.md Contains the licensing terms and copyright notice for this repository. Makefile SmartNIC platform Makefile. Used to build the FPGA bitfile for the target application, as well as generate all artifacts necessary for firmware integration on the hardware platform. makefile.esnet OpenNIC shell Makefile. Used to build the AMD (Xilinx) open-nic-shell for the target application. open-nic_shell/ Contains the AMD (Xilinx) OpenNIC Shell repository (imported as a git submodule). OpenNIC shell delivers an FPGA-based NIC shell with 100Gbps Ethernet ports, for use on the AMD (Xilinx) Alveo platform. paths.mk Describes paths to resources provided by the SmartNIC project. README.md This README file. scripts/ Contains SmartNIC platform scripts, for application configuration. src/ Contains RTL source and verification code for SmartNIC platform FPGA design components, captured in System Verilog.","title":"Directory Structure"},{"location":"2-lesson2/#installing-the-smartnic-hardware-design-repository","text":"The following steps guide a new user through the installation of the SmartNIC Hardware Design Repository, beginning with a suitably-configured host running Ubuntu 20.04 LTS Linux. Install the esnet-smartnic-hw respository by creating a clone from github into a local directory: git clone https://github.com/esnet/esnet-smartnic-hw.git Initialize all submodules within the esnet-smartnic-hw/ design directory: cd esnet-smartnic-hw git submodule update --init --recursive Install the prerequisites required to run the esnet regio tools: sudo apt install python3-yaml python3-jinja2 python3-click pip3 install -r esnet-fpga-library/tools/regio/requirements.txt Note: The above instructions and more details about the regio tools can be found in the README file at: esnet-fpga-library/tools/regio/README.md","title":"Installing the SmartNIC Hardware Design Repository"},{"location":"2-lesson2/#building-the-smartnic-p4_only-example-design","text":"You can build the p4_only example design by executing its Makefile. Follow these steps: Navigate to the p4_only example design directory: ```shell cd examples/p4_only ``` Modify the Makefile to ensure that export BOARD is set to the target card (i.e au280 or au55c): ```shell export BOARD := au280 ``` Make sure to source the Vivado environment script: ```shell source /tools/Xilinx/Vivado/2023.1/settings.64.sh ``` At the time of writing this guide, 2023.1 was the version supported by the ESnet framework. Please refer to the README on the ESnet repositories. Run the Makefile to build the design: ```shell make ``` Upon completion, you'll find an artifact zipfile with the default pathname: artifacts/<BUILD_NAME>/artifacts.<BOARD>.<BUILD_NAME>.0.zip . This artifact zipfile contains all necessary hardware artifacts, including the bitfile, firmware driver files, regmap YAML files, the source P4 file, and any Wireshark .lua files. For more details about the p4_only design and simulating the P4 program, refer to the examples/p4_only/README.md file. You can find more information on the ESnet development workflow here: ESnet Development Workflow .","title":"Building the SmartNIC p4_only Example Design"},{"location":"2-lesson2/#building-a-new-p4-application","text":"The following steps can be taken by a new user to setup a local application design directory for building the bitfile and artifacts for a custom P4-based SmartNIC application. Install the esnet-smartnic-hw respository (as described above). Or, alternatively, add the esnet-smartnic-hw respository to an existing git repository as a sub-module: > git submodule add https://github.com/esnet/esnet-smartnic-hw.git Initialize all submodules within the esnet-smartnic-hw/ design directory: cd esnet-smartnic-hw git submodule update --init --recursive Install Vivado and configure the runtime environment (as described above). Return to the local application design directory and then copy the example SmartNIC application Makefile and p4/ sub-directory into the local application design directory: cd ../ cp esnet-smartnic-hw/examples/p4_only/Makefile ./ cp -r esnet-smartnic-hw/examples/p4_only/p4 ./ Using a preferred editor, edit the copied Makefile to update the SMARTNIC_DIR environment variable assignment as follows: #SMARTNIC_DIR := ../.. SMARTNIC_DIR := $(CURDIR)/esnet-smartnic-hw Copy the application p4 file to the following location and filename: cp p4/ basename $PWD .p4 Note: By default, the SmartNIC scripts take the basename of the application design directory to be the name of the application, as well as its associated filenames. Make sure to source the Vivado environment script: ```shell source /tools/Xilinx/Vivado/2023.1/settings.64.sh ``` At the time of writing this guide, 2023.1 was the version supported by the ESnet framework. Please refer to the README on the ESnet repositories. Build the design by executing the copied application Makefile: make To simulate the P4 program, refer to the readme file provided in the p4/sim/ directory i.e. p4/sim/README.md","title":"Building a New P4 Application"},{"location":"2-lesson2/#p4-programming-requirements","text":"The P4 processing core of the SmartNIC platform is implemented with the AMD (Xilinx) VitisNetP4 IP core. In order to meet the requirements of the VitisNetP4 IP core and the SmartNIC platform, a new P4 program should consider the following guidelines.","title":"P4 Programming Requirements"},{"location":"2-lesson2/#amd-xilinx-p4-architecture","text":"The Vitis Networking P4 compiler supports a specific pipelined datapath architecture that is comprised of 3 customizable stages: A Parser Engine, followed by a Match-Action Engine, followed by a Deparser Engine. User P4 files MUST be structured to comply with this processing architecture, and specify the custom operations desired within each of these processing stages. More details about the AMD (Xilinx) P4 architecture can be found in the Vitis Networking P4 User Guide, UG1308 (v2023.1) May 16, 2023 .","title":"AMD (Xilinx) P4 Architecture:"},{"location":"2-lesson2/#include-files","text":"The P4 program MUST include the following AMD (Xilinx) VitisNetP4 include files: #include <core.p4> #include <xsa.p4> These files capture built-in constructs and the standard definitions for the AMD (Xilinx) P4 architecture. They are located in the Vivado installation directory at: $XILINX_VIVADO/data/ip/xilinx/vitis_net_p4_v1_1/include/p4/","title":"Include files:"},{"location":"2-lesson2/#interfaces","text":"The P4 processing core supports 3 types of interfaces: Packet Ports are the primary interfaces responsible for moving packets in and out of the core, as well as between engines. Engines can only contain a single input packet port and a single output packet port. Metadata Ports carry sideband data related to a packet. Metadata can only correspond to a single packet and is processed in parallel with the packet. More on Metadata below. Register IO Ports (axi4l) are used to control the contents of the Look-up engines.","title":"Interfaces:"},{"location":"2-lesson2/#metadata-definitions","text":"The VitisNetP4 core supports both Standard Metadata (defined and set by the P4 core), and User Metadata (defined and set by the SmartNIC platform). Both types of metadata can be read and/or written by the P4 program. For more details about the Standard Metadata definitions, see Vitis Networking P4 User Guide, UG1308 (v2023.1) May 16, 2023 . In order for the compiled VitisNetP4 core to match the SmartNIC application interface, a user P4 program MUST define the User Metadata structure as follows: struct smartnic_metadata { bit<64> timestamp_ns; // 64b timestamp (in nanoseconds). Set at packet arrival time. bit<16> pid; // 16b packet id used by platform (READ ONLY - DO NOT EDIT). bit<3> ingress_port; // 3b ingress port (0:CMAC0, 1:CMAC1, 2:HOST0, 3:HOST1). bit<3> egress_port; // 3b egress port (0:CMAC0, 1:CMAC1, 2:HOST0, 3:HOST1). bit<1> truncate_enable; // reserved (tied to 0). bit<16> truncate_length; // reserved (tied to 0). bit<1> rss_enable; // reserved (tied to 0). bit<12> rss_entropy; // reserved (tied to 0). bit<4> drop_reason; // reserved (tied to 0). bit<32> scratch; // reserved (tied to 0). }","title":"Metadata Definitions:"},{"location":"2-lesson2/#lookup-engines-and-externs","text":"In order for the compiled VitisNetP4 core to match the SmartNIC application interface, a user Program MUST have: One (or more) Look-up Engines. No HBM BCAMs. No Externs. Support for these features may be added in a future release.","title":"Lookup Engines and Externs:"},{"location":"2-lesson2/#the-tldr","text":"You can simply do: cd examples/p4_only/p4 and here you can modify the p4 program. If you run make it will compile your P4 program into the Xilinx FPGA board model specified in Makefile .","title":"The tl;dr"},{"location":"2-lesson2/#p4-simulation-p4_only","text":"The p4_only example design provides the P4 source code and a behavioural simulation testcase for a simple P4 application core. This example follows a pure P4 design flow and does NOT include any custom verilog hardware. As such, the user only provides the working P4 program file to build the custom SmartNIC hardware.","title":"P4 Simulation: p4_only"},{"location":"2-lesson2/#functional-specification","text":"The p4_only design implements a simple table-based Layer-2 packet switch. It uses a single LPM lookup table that takes the Ethernet Destination MAC Address field as the key. When the lookup matches, the table returns the programmed destination port for the specified packet flow. The returned destination port is then written into the output metadata ( egress_port field), which is used by the SmartNIC hardware for packet forwarding. When the lookup misses, the output metadata remains unchanged and the packet is forwarded to the destination port that was specified in the packet's input metadata ( egress_port field). Packets with invalid and errored Ethernet headers are dropped.","title":"Functional Specification"},{"location":"2-lesson2/#makefile","text":"The execution of P4 behavioural simulations is driven by the Makefile in the p4/sim/ directory. This Makefile includes the variable assignments that specify how to run a p4 behavioural simulation, as well as the name of the p4 file and list of testcases that should be included in a full simulation run. Each testcase is captured in a separate subdirectory, which contains the input and output files for the specified test. The testcase subdirectories follow the naming pattern of test-<NAME> . Prior to running a simulation, the user should update the Makefile with the following variable assignments (all other variable assignments can remain unchanged): P4_SOURCE = <pathname of p4 source file> P4BM_DIRS = <testcase subdirectory list> The Makefile includes execution targets to run (or clean) a single testcase simulation, or simulation of the full testcase suite. To simulate a single testcase, execute make with the P4BM_DIR= argument set to the testcase subdirectory of interest. For example: > make P4BM_DIR=test-fwd-p0 Or to simulate all test cases: > make sim-all Note: the sim-all target is the default target when make is called without arguments. To clean all simulation output products from the p4 directory, type: > make clean","title":"Makefile"},{"location":"2-lesson2/#terminal-configuration","text":"If you encounter the following warning when using rlwrap: rlwrap: warning: your $TERM is 'xterm-256color' but rlwrap couldn't find it in the terminfo database. Expect some problems. You can resolve this issue by adding the following line to your .profile file: export TERM=xterm1","title":"Terminal Configuration"},{"location":"2-lesson2/#testcase-input-files","text":"The input stimulus file set for each testcase includes three files: cli_commands.txt - Command script to set table entries and initiate input stimulus. Commands and syntax follow the Xilinx p4bm-vitisnet-cli. packets_in.user - Input packet stream user data. Each byte sequence terminated by a semicolon (;) represents a packet. Packets are captured in sequence. The '%' character is used to start comments. packets_in.pcap - PCAP file containing the input packet stream. Alternative format to packets_in.user (optional). packets_in.meta - Input packet metadata. Each line corresponds to a packet in the input PCAP file (in sequence). The syntax of the metadata is described in the Xilinx VitisnetP4 documentation. Note: Each metadata record must be terminated by a semicolon (;). For more details, see chapter 3 of Vitis Networking P4 User Guide, UG1308 (v2023.1) May 16, 2023 .","title":"Testcase Input Files"},{"location":"2-lesson2/#testcase-output-files","text":"packets_out.user - Output packet stream user data. Same syntax as input packet stream user data. packets_out.pcap - PCAP file containing the output packet stream, if packets_in format was packets_in.pcap . packets_out.meta - Output packet metadata. Each line corresponds to a packet in the output PCAP file (in sequence). Same syntax as input packet metadata. Note: An expected/ directory is optionally included to capture the expected output results of a testcase. This expected output can be used for automated regression testing.","title":"Testcase Output Files"},{"location":"2-lesson2/#testcases-p4_only","text":"test-fwd-p0 - The p4_only design includes a single example testcase called test-fwd-p0. This testcase programs a small number of table entries that forward the specified packet flows to destination port 0. The input stimulus includes a single packet on each flow to validate that all packets are forwarded to port 0. All other packets are forwarded to the egress_port specified by the input meta data.","title":"Testcases: p4_only"},{"location":"2-lesson2/#generating-and-simulating-the-amd-xilinx-vitisnetp4-example-design","text":"Prior to generating the AMD (Xilinx) vitisnetp4 example design, a user must specify the p4bm test directory that will be imported for simulation. This is done by assigning the full directory pathname to the EXAMPLE_TEST_DIR variable in the application Makefile. For example: export EXAMPLE_TEST_DIR := $(CURDIR)/p4/sim/test-fwd-p0 By setting the above Makefile variable, the example design will import all input stimulus, CLI programming, and any (optional) extern behvioural models associated with the specified simulation testcase. The AMD (Xilinx) vitisnetp4 example design can be generated in the local application design directory by running the 'example' target of the root-level application Makefile, as follows: make example Executing the above make command will generate the vitisnetp4 example design in a subdirectory called example/sdnet_0_ex/ . From the example/sdnet_0_ex/ subdirectory, the AMD (Xilinx) Vivado tool can be invoked, the example design project can be opened, and the p4 processor can be simulated, as follows: cd example/sdnet_0_ex vivado From the File->Project->Open... menu, select 'sdnet_0_ex.xpr' and open the example design project. From the Flow Navigator menu, select 'Simulation->Run Simulation->Run Behavioural Simulation'. For more information about how to simulate designs and evaluate results within the AMD (Xilinx) Vivado GUI, refer to the following document: Vivado Design Suite User Guide - Logic Simulation, UG900 (v2023.1) May 10, 2023. Note that vitisnetp4 example design generation supports the optional instantiation of custom user extern function(s) by including the following design files: System Verilog RTL code for custom extern function(s) in the file extern/rtl/smartnic_extern.sv . Furthermore, if a user captures extern function(s) in a design hierarchy comprised of multiple .sv files, all of the .sv files located in the extern/rtl directory will be included in the example design project, C++ behavioural model(s) for custom extern function(s) in the file p4/sim/user_externs/smartnic_extern.cpp Furthermore, when simulating the vitisnetp4 example design with a user extern, the smartnic_extern instantiation is located within the example_dut_wrapper module (instance name dut_inst/smartnic_extern_0 ).","title":"Generating and Simulating the AMD (Xilinx) Vitisnetp4 Example Design"},{"location":"2-lesson2/#references","text":"This tutorial is built on the following software/respositories along with versions/commits: Ubuntu 20.04 with Linux 5.4.0-153. Vivado 2023.1 with the VitisNetowrkingP4 license. The esnet-smartnic-hw repository (commit: 9ee2cbb). The esnet-smartnic-fw repository (commit: 180595c). The smartnic-dpdk-docker repository (commit: a52dba3). The xilinx-labtools-docker repository (commit: 84cf05f).","title":"References"},{"location":"2-lesson2/#known-issues","text":"None to date. If you face any issues, please contact mailto:cs595-f2023-group@iit.edu","title":"Known Issues"},{"location":"2-lesson2/#lesson-3-the-deployment-workflow","text":"Link: Lesson 3: The Deployment Workflow","title":"Lesson 3: The Deployment Workflow"},{"location":"3-lesson3/","text":"Lesson 3: The Deployment Workflow In this lesson, we will explore the deployment workflow, which involves the deployment of compiled bitfiles (zipped artifacts) onto the FPGA card. This stage results in a stack of three essential Docker images, namely: esnet-smartnic-fw : This Docker image is crucial for your specific bitfiles (artifacts). You will need to rebuild it each time you modify the bitfiles. It's important to note that the rebuilding process becomes significantly faster after the first time. smartnic-dpdk-docker : This image is bitfile-independent and only needs to be built once. It serves as an essential component for interacting with the FPGA card. You can tar this image and transfer it to your runtime environment, provided that the host system where it was created matches the CPU architecture of your runtime environment. This Docker image provides the DPDK and pktgen tools. xilinx-labtools-docker : Similar to the smartnic-dpdk-docker image, this Docker image is bitfile-independent and needs to be constructed only once. It complements the functionality of the FPGA card and is transferable to your runtime environment, given the aforementioned CPU architecture compatibility. This Docker image gives you access to Vivado Lab (no license needed). Vivado Lab is the software you'll use to load new programs onto your FPGA, so it's a crucial part of the setup. It's crucial to ensure that all three Docker images, along with the corresponding configuration files, are present to effectively utilize the ESnet framework on an FPGA card. This deployment process can be replicated on multiple hosts with FPGAs as well, as long as the three containers and the sn-stack/ folder are available on the new host. Once the deployment is complete, you gain access to a powerful set of tools for your experiments: DPDK (Data Plane Development Kit) : DPDK is an application that enables you to bypass the kernel of the slice and connect directly to the FPGA. This allows for high-performance packet processing and efficient data plane operations. Pktgen : Pktgen is a DPDK application that facilitates the transmission of packets to and from the FPGA SmartNIC through its 2x100 Gbps ports. It also enables communication with the slice host using the PCIe bus. Pktgen is a valuable tool for testing and analyzing network performance. ESnet CLI Tools : These command-line tools provide control over the QDMA queues, access to probe counters for packet statistics, management of the control plane rules for your P4 logic, and remapping of egress ports to suit the requirements of your specific experiment. Setting up the build environment The smartnic firmware build depends on docker and the docker compose plugin. Docker Install Docker on your system following the instructions found here for the linux variant that you are using * https://docs.docker.com/engine/install/ Ensure that you follow the post-install instructions here so that you can run docker without sudo * https://docs.docker.com/engine/install/linux-postinstall/ Verify your docker setup by running this as an ordinary (non-root) user without using sudo docker run hello-world Docker Compose The docker-compose.yml file for the smartnic build and the sn-stack depends on features that are only supported in the compose v2 plugin. Install the docker compose plugin like this for a single user: mkdir -p ~/.docker/cli-plugins/ curl -SL https://github.com/docker/compose/releases/download/v2.17.2/docker-compose-linux-x86_64 -o ~/.docker/cli-plugins/docker-compose chmod +x ~/.docker/cli-plugins/docker-compose Alternatively, you can install the docker compose plugin system-wide like this: sudo mkdir -p /usr/local/lib/docker/cli-plugins sudo curl -o /usr/local/lib/docker/cli-plugins/docker-compose -SL https://github.com/docker/compose/releases/download/v2.17.2/docker-compose-linux-x86_64 sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose Verify your docker compose installation by running this as an ordinary (non-root) user without using sudo . For this install, the version output should be $ docker compose version Docker Compose version v2.17.2 Git Submodules Ensure that all submodules have been pulled. git submodule init git submodule update Building a new firmware image Install Smartnic Hardware Build Artifact The firmware build depends on the result of a smartnic hardware (FPGA) build. This file must be available prior to invoking the firmware build. This file will be called artifacts.<board>.<app_name>.0.zip and should be placed in the sn-hw directory in your source tree before starting the firmware build. Create 'smartnic-dpdk-docker' Image Clone the repository: git clone https://github.com/esnet/smartnic-dpdk-docker.git Installing git submodules git submodule update --init --recursive Building the smartnic-dpdk-docker container docker build --pull -t smartnic-dpdk-docker:${USER}-dev . docker image ls You should see an image called smartnic-dpdk-docker with tag ${USER}-dev . Alternatively, you can tar this image and transfer it to your runtime environment, provided that the host system where it was created matches the CPU architecture of the environment. Create 'xilinx-labtools-docker' Image Clone the repository: git clone https://github.com/esnet/xilinx-labtools-docker.git Download the Xilinx Labtools Installer Open a web browser to this page: https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vivado-design-tools/2023-1.html Under the Vivado Lab Solutions - 2023.1 section Download Vivado 2023.1: Lab Edition - Linux Save the file as exactly: Xilinx_Vivado_Lab_Lin_2023.1_0507_1903.tar.gz Move the file into the vivado-installer directory in this repo $ tree . \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 sources.list.focal \u2514\u2500\u2500 vivado-installer \u251c\u2500\u2500 install_config_lab.2023.1.txt \u2514\u2500\u2500 Xilinx_Vivado_Lab_Lin_2023.1_0507_1903.tar.gz <------- put the installer here Building the xilinx-labtools container docker build --pull -t xilinx-labtools-docker:${USER}-dev . docker image ls You should see an image called xilinx-labtools-docker with tag ${USER}-dev . Alternatively, you can tar this image and transfer it to your runtime environment, provided that the host system where it was created matches the CPU architecture of the environment. Building a new firmware image Clone the esnet-smartnic-fw repository git clone https://github.com/esnet/esnet-smartnic-fw.git Git Submodules Ensure that all submodules have been pulled. git submodule init git submodule update Install Smartnic Hardware Build Artifact The firmware build depends on the result of a smartnic hardware (FPGA) build. This file must be available prior to invoking the firmware build. This file will be called artifacts.<board>.<app_name>.0.zip and should be placed in the sn-hw directory in your source tree before starting the firmware build. Set up your .env file for building a new firmware image The .env file tells the build about its inputs and outputs. There is an example.env file in top level directory of this repo that will provide documentation and examples for the values you need to set. cd $(git rev-parse --show-toplevel) cp example.env .env Since the values in the .env file are used to locate the correct hardware artifact, you will need to (at least) set these values in the .env file to match the exact naming of the .zip file you installed in the previous step: SN_HW_BOARD=<board> SN_HW_APP_NAME=<app_name> SN_HW_VER=0 Build the firmware The firmware build creates a docker container with everything needed to interact with your FPGA image. Without any parameters, the newly built firmware container will be named/tagged esnet-smartnic-fw:${USER}-dev and will be available only on the local system. cd $(git rev-parse --show-toplevel) ./build.sh Optionally you can use any alternative name by specifying the full container URI as an optional parameter to the build script like this. Using a fully specified URI here can be useful if you are planning to push the newly built container to a remote docker registry. ./build.sh wharf.es.net/ht/esnet-smartnic-fw:${USER}-dev The build script also automatically customizes the sn-stack/.env file to refer exactly to the firmware image that you just built. The entire sn-stack directory will need to be transferred to the runtime system. cd $(git rev-parse --show-toplevel) zip -r artifacts.esnet-smartnic-fw.package.0.zip sn-stack Configuring the firmware runtime environment Optionally The firmware artifact produced by the build (see README.md at the top of this repo) should be transferred to the runtime system that hosts an FPGA card. If your runtime system that hosts an FPGA card is the same one you built the firmware artifacts on (the same one you ran build.sh on), you can skip this step entirely. unzip artifacts.esnet-smartnic-fw.package.0.zip cd sn-stack # edit the .env file to provide sane values for # FPGA_PCIE_DEV=0000:d8:00 # COMPOSE_PROFILES=smartnic-mgr-vfio-unlock # and IFF you have more than one JTAG you also need a line like this # HW_TARGET_SERIAL=21760204S029A Verify that the stack configuration is valid docker compose config --quiet && echo \"All good!\" If this prints anything other than \"All good!\" then your .env configuration file has errors. Do not proceed until this step passes. References This tutorial is built on the following software/respositories along with versions/commits: Ubuntu 20.04 with Linux 5.4.0-153. Vivado 2023.1 with the VitisNetowrkingP4 license. The esnet-smartnic-hw repository (commit: 9ee2cbb). The esnet-smartnic-fw repository (commit: 180595c). The smartnic-dpdk-docker repository (commit: a52dba3). The xilinx-labtools-docker repository (commit: 84cf05f). Known Issues None to date. If you face any issues, please contact mailto:cs595-f2023-group@iit.edu Lesson 4: Running the Deployment Link: Lesson 4: Running the Deployment","title":"Lesson 3"},{"location":"3-lesson3/#lesson-3-the-deployment-workflow","text":"In this lesson, we will explore the deployment workflow, which involves the deployment of compiled bitfiles (zipped artifacts) onto the FPGA card. This stage results in a stack of three essential Docker images, namely: esnet-smartnic-fw : This Docker image is crucial for your specific bitfiles (artifacts). You will need to rebuild it each time you modify the bitfiles. It's important to note that the rebuilding process becomes significantly faster after the first time. smartnic-dpdk-docker : This image is bitfile-independent and only needs to be built once. It serves as an essential component for interacting with the FPGA card. You can tar this image and transfer it to your runtime environment, provided that the host system where it was created matches the CPU architecture of your runtime environment. This Docker image provides the DPDK and pktgen tools. xilinx-labtools-docker : Similar to the smartnic-dpdk-docker image, this Docker image is bitfile-independent and needs to be constructed only once. It complements the functionality of the FPGA card and is transferable to your runtime environment, given the aforementioned CPU architecture compatibility. This Docker image gives you access to Vivado Lab (no license needed). Vivado Lab is the software you'll use to load new programs onto your FPGA, so it's a crucial part of the setup. It's crucial to ensure that all three Docker images, along with the corresponding configuration files, are present to effectively utilize the ESnet framework on an FPGA card. This deployment process can be replicated on multiple hosts with FPGAs as well, as long as the three containers and the sn-stack/ folder are available on the new host. Once the deployment is complete, you gain access to a powerful set of tools for your experiments: DPDK (Data Plane Development Kit) : DPDK is an application that enables you to bypass the kernel of the slice and connect directly to the FPGA. This allows for high-performance packet processing and efficient data plane operations. Pktgen : Pktgen is a DPDK application that facilitates the transmission of packets to and from the FPGA SmartNIC through its 2x100 Gbps ports. It also enables communication with the slice host using the PCIe bus. Pktgen is a valuable tool for testing and analyzing network performance. ESnet CLI Tools : These command-line tools provide control over the QDMA queues, access to probe counters for packet statistics, management of the control plane rules for your P4 logic, and remapping of egress ports to suit the requirements of your specific experiment.","title":"Lesson 3: The Deployment Workflow"},{"location":"3-lesson3/#setting-up-the-build-environment","text":"The smartnic firmware build depends on docker and the docker compose plugin.","title":"Setting up the build environment"},{"location":"3-lesson3/#docker","text":"Install Docker on your system following the instructions found here for the linux variant that you are using * https://docs.docker.com/engine/install/ Ensure that you follow the post-install instructions here so that you can run docker without sudo * https://docs.docker.com/engine/install/linux-postinstall/ Verify your docker setup by running this as an ordinary (non-root) user without using sudo docker run hello-world","title":"Docker"},{"location":"3-lesson3/#docker-compose","text":"The docker-compose.yml file for the smartnic build and the sn-stack depends on features that are only supported in the compose v2 plugin. Install the docker compose plugin like this for a single user: mkdir -p ~/.docker/cli-plugins/ curl -SL https://github.com/docker/compose/releases/download/v2.17.2/docker-compose-linux-x86_64 -o ~/.docker/cli-plugins/docker-compose chmod +x ~/.docker/cli-plugins/docker-compose Alternatively, you can install the docker compose plugin system-wide like this: sudo mkdir -p /usr/local/lib/docker/cli-plugins sudo curl -o /usr/local/lib/docker/cli-plugins/docker-compose -SL https://github.com/docker/compose/releases/download/v2.17.2/docker-compose-linux-x86_64 sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose Verify your docker compose installation by running this as an ordinary (non-root) user without using sudo . For this install, the version output should be $ docker compose version Docker Compose version v2.17.2","title":"Docker Compose"},{"location":"3-lesson3/#git-submodules","text":"Ensure that all submodules have been pulled. git submodule init git submodule update","title":"Git Submodules"},{"location":"3-lesson3/#building-a-new-firmware-image","text":"","title":"Building a new firmware image"},{"location":"3-lesson3/#install-smartnic-hardware-build-artifact","text":"The firmware build depends on the result of a smartnic hardware (FPGA) build. This file must be available prior to invoking the firmware build. This file will be called artifacts.<board>.<app_name>.0.zip and should be placed in the sn-hw directory in your source tree before starting the firmware build.","title":"Install Smartnic Hardware Build Artifact"},{"location":"3-lesson3/#create-smartnic-dpdk-docker-image","text":"Clone the repository: git clone https://github.com/esnet/smartnic-dpdk-docker.git Installing git submodules git submodule update --init --recursive Building the smartnic-dpdk-docker container docker build --pull -t smartnic-dpdk-docker:${USER}-dev . docker image ls You should see an image called smartnic-dpdk-docker with tag ${USER}-dev . Alternatively, you can tar this image and transfer it to your runtime environment, provided that the host system where it was created matches the CPU architecture of the environment.","title":"Create 'smartnic-dpdk-docker' Image"},{"location":"3-lesson3/#create-xilinx-labtools-docker-image","text":"Clone the repository: git clone https://github.com/esnet/xilinx-labtools-docker.git Download the Xilinx Labtools Installer Open a web browser to this page: https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vivado-design-tools/2023-1.html Under the Vivado Lab Solutions - 2023.1 section Download Vivado 2023.1: Lab Edition - Linux Save the file as exactly: Xilinx_Vivado_Lab_Lin_2023.1_0507_1903.tar.gz Move the file into the vivado-installer directory in this repo $ tree . \u251c\u2500\u2500 Dockerfile \u251c\u2500\u2500 sources.list.focal \u2514\u2500\u2500 vivado-installer \u251c\u2500\u2500 install_config_lab.2023.1.txt \u2514\u2500\u2500 Xilinx_Vivado_Lab_Lin_2023.1_0507_1903.tar.gz <------- put the installer here Building the xilinx-labtools container docker build --pull -t xilinx-labtools-docker:${USER}-dev . docker image ls You should see an image called xilinx-labtools-docker with tag ${USER}-dev . Alternatively, you can tar this image and transfer it to your runtime environment, provided that the host system where it was created matches the CPU architecture of the environment.","title":"Create 'xilinx-labtools-docker' Image"},{"location":"3-lesson3/#building-a-new-firmware-image_1","text":"","title":"Building a new firmware image"},{"location":"3-lesson3/#clone-the-esnet-smartnic-fw-repository","text":"git clone https://github.com/esnet/esnet-smartnic-fw.git","title":"Clone the esnet-smartnic-fw repository"},{"location":"3-lesson3/#git-submodules_1","text":"Ensure that all submodules have been pulled. git submodule init git submodule update","title":"Git Submodules"},{"location":"3-lesson3/#install-smartnic-hardware-build-artifact_1","text":"The firmware build depends on the result of a smartnic hardware (FPGA) build. This file must be available prior to invoking the firmware build. This file will be called artifacts.<board>.<app_name>.0.zip and should be placed in the sn-hw directory in your source tree before starting the firmware build.","title":"Install Smartnic Hardware Build Artifact"},{"location":"3-lesson3/#set-up-your-env-file-for-building-a-new-firmware-image","text":"The .env file tells the build about its inputs and outputs. There is an example.env file in top level directory of this repo that will provide documentation and examples for the values you need to set. cd $(git rev-parse --show-toplevel) cp example.env .env Since the values in the .env file are used to locate the correct hardware artifact, you will need to (at least) set these values in the .env file to match the exact naming of the .zip file you installed in the previous step: SN_HW_BOARD=<board> SN_HW_APP_NAME=<app_name> SN_HW_VER=0","title":"Set up your .env file for building a new firmware image"},{"location":"3-lesson3/#build-the-firmware","text":"The firmware build creates a docker container with everything needed to interact with your FPGA image. Without any parameters, the newly built firmware container will be named/tagged esnet-smartnic-fw:${USER}-dev and will be available only on the local system. cd $(git rev-parse --show-toplevel) ./build.sh Optionally you can use any alternative name by specifying the full container URI as an optional parameter to the build script like this. Using a fully specified URI here can be useful if you are planning to push the newly built container to a remote docker registry. ./build.sh wharf.es.net/ht/esnet-smartnic-fw:${USER}-dev The build script also automatically customizes the sn-stack/.env file to refer exactly to the firmware image that you just built. The entire sn-stack directory will need to be transferred to the runtime system. cd $(git rev-parse --show-toplevel) zip -r artifacts.esnet-smartnic-fw.package.0.zip sn-stack","title":"Build the firmware"},{"location":"3-lesson3/#configuring-the-firmware-runtime-environment","text":"Optionally The firmware artifact produced by the build (see README.md at the top of this repo) should be transferred to the runtime system that hosts an FPGA card. If your runtime system that hosts an FPGA card is the same one you built the firmware artifacts on (the same one you ran build.sh on), you can skip this step entirely. unzip artifacts.esnet-smartnic-fw.package.0.zip cd sn-stack # edit the .env file to provide sane values for # FPGA_PCIE_DEV=0000:d8:00 # COMPOSE_PROFILES=smartnic-mgr-vfio-unlock # and IFF you have more than one JTAG you also need a line like this # HW_TARGET_SERIAL=21760204S029A Verify that the stack configuration is valid docker compose config --quiet && echo \"All good!\" If this prints anything other than \"All good!\" then your .env configuration file has errors. Do not proceed until this step passes.","title":"Configuring the firmware runtime environment"},{"location":"3-lesson3/#references","text":"This tutorial is built on the following software/respositories along with versions/commits: Ubuntu 20.04 with Linux 5.4.0-153. Vivado 2023.1 with the VitisNetowrkingP4 license. The esnet-smartnic-hw repository (commit: 9ee2cbb). The esnet-smartnic-fw repository (commit: 180595c). The smartnic-dpdk-docker repository (commit: a52dba3). The xilinx-labtools-docker repository (commit: 84cf05f).","title":"References"},{"location":"3-lesson3/#known-issues","text":"None to date. If you face any issues, please contact mailto:cs595-f2023-group@iit.edu","title":"Known Issues"},{"location":"3-lesson3/#lesson-4-running-the-deployment","text":"Link: Lesson 4: Running the Deployment","title":"Lesson 4: Running the Deployment"},{"location":"4-lesson4/","text":"Lesson 4: Running the Deployment Converting from factory flash image to ESnet Smartnic flash image From the factory, the FPGA cards have only a \"gold\" bitfile in flash with the \"user\" partition of flash being blank. The \"gold\" bitfile has a narrow PCIe memory window for BAR1 and BAR2 which is insufficient for the ESnet Smartnic platform. Fixing this requires a one-time flash programming step to install an ESnet Smartnic bitfile into the FPGA \"user\" partition in flash. This initial setup is done using the JTAG. Ensure that any running sn-stack instances have been stopped so that they don't interfere with the flash programming operation. docker compose down -v --remove-orphans Start the flash rescue service to program an ESnet Smartnic bitfile into the FPGA card \"user\" partition using the JTAG interface. This takes approximately 20 minutes. This process should not be interrupted. docker compose --profile smartnic-flash run --rm smartnic-flash-rescue This will: * Use JTAG to write a small flash-programing helper bitfile into the FPGA * Use JTAG to write the current version of the bitfile into the FPGA card's \"user\" partition in flash * Only the \"user\" partition of the flash is overwritten by this step * The \"gold\" partition is left untouched Clean up by bringing down the running stack after flash writing has completed. docker compose down -v --remove-orphans Perform a cold-boot (power cycle) of the server hosting the FPGA card It is essential that this is a proper power cycle and not simply a warm reboot. Specifically do not use shutdown -r now but rather use something like ipmitool chassis power cycle . Failure to perform a cold-boot here will result in an unusable card. Normal Operation of the Runtime Environment Running the firmware Start up the full firmware docker stack like this docker compose up -d Verifying the bitfile download docker compose logs smartnic-hw Inspecting registers and interacting with the firmware The firmware runtime environment exists inside of the smartnic-fw container. Here, we exec a shell inside of that container and have a look around. docker compose exec smartnic-fw bash sn-cli dev version regio syscfg If this prints wrong values or all ones, make sure you don\u2019t have the COMPOSE_PROFILES set to smartnic-mgr-dpdk-manual in your sn-stack/.env file. Otherwise, you will not be able to access any sn-cli tools unless pktgen is running. (OPTIONAL) Updating the flash image to a new ESnet Smartnic flash image The instructions in this section are used to update the Smartnic flash image from an already working Smartnic environment. This update step is optional and only required if you want to change the contents of the FPGA card flash. Normally, the \"RAM\" of the FPGA is loaded using JTAG during stack startup. NOTE This will not work for the very first time ever programming the flash. See \"Converting from factory flash image to ESnet Smartnic flash image\" section above for first-time setup. Start up a any properly configured stack which will allow us to write the flash using a fast algorithm over PCIe. docker compose up -d Confirm that PCIe register IO is working in your stack by querying the version registers. docker compose exec smartnic-fw sn-cli dev version Confirm that the \"DNA\" register is not showing 0xfffff... as its contents. Start the flash update service to write the currently active FPGA bitfile into the persistent flash on the FPGA card. This takes approximately 7-8 minutes. This process should not be interrupted. docker compose --profile smartnic-flash run --rm smartnic-flash-update Bring down the running stack after flash writing has completed. docker compose down -v --remove-orphans (OPTIONAL) Remove the ESnet Smartnic flash image from the FPGA card to revert to factory image The instructions in this section are used to remove the Smartnic flash image from an already working Smartnic environment. This removal step is optional and only required if you want to reset the contents of the FPGA card flash back to the factory bitfile. If you want to keep using the card as an ESnet Smartnic, do not perform these operations or you'll have to re-do the \"Converting from factory flash image to ESnet Smartnic flash image\" section above. Start up a any properly configured stack which will allow us to write the flash using a fast algorithm over PCIe. docker compose up -d Confirm that PCIe register IO is working in your stack by querying the version registers. docker compose exec smartnic-fw sn-cli dev version Confirm that the \"DNA\" register is not showing 0xfffff... as its contents. Start the flash remove service to erase the ESnet Smartnic image from the \"user\" partition of the FPGA card flash. This takes less than 1 minute. This process should not be interrupted. docker compose --profile smartnic-flash run --rm smartnic-flash-remove Bring down the running stack after flash reset is completed. docker compose down -v --remove-orphans Note: If you want to flash the golden (recovery) image and it is not working, you can use vivado_lab with the following commands: vivado_lab \\ -nolog \\ -nojournal \\ -tempDir /tmp/ \\ -mode batch \\ -notrace \\ -quiet \\ -source /scripts/program_flash.tcl \\ -tclargs \"$HW_SERVER_URL\" \"$HW_TARGET_SERIAL\" \"/scripts/revert_to_golden.mcs\" If you don't know how to set it up, you can go to sn-stack/smartnic-hw/scripts and put the \"revert to golden\" image there. For more information on how to get the golden image, you can refer to this link . After placing the image there, you can modify the program_flash.sh script and change: vivado_lab \\ -nolog \\ -nojournal \\ -tempDir /tmp/ \\ -mode batch \\ -notrace \\ -quiet \\ -source /scripts/program_flash.tcl \\ -tclargs \"$HW_SERVER_URL\" \"$HW_TARGET_SERIAL\" \"$MCSFILE_PATH To: vivado_lab \\ -nolog \\ -nojournal \\ -tempDir /tmp/ \\ -mode batch \\ -notrace \\ -quiet \\ -source /scripts/program_flash.tcl \\ -tclargs \"$HW_SERVER_URL\" \"$HW_TARGET_SERIAL\" \"/scripts/revert_to_golden.mcs\" After a cold reboot, you will see the cards are back to the golden image. Important notice: The golden image will not make the cards appear in XRT, as XRT needs an \"XRT-friendly\" shell. However, it'll make xbmgmt see the card, and from there, you can flash a new platform that works with XRT. For more info on the golden image, you can refer to this documentation . Using the sn-cli tool The sn-cli tool provides subcommands to help you accomplish many common tasks for inspecting and configuring the smartnic platform components. All commands described below are expected to be executed within the smartnic-fw container environment. Use this command to enter the appropriate environment. docker compose exec smartnic-fw bash The sn-cli tool will automatically look for an environment variable called SN_CLI_SLOTADDR which can be set to the PCIe BDF address of the device that you would like to interract with. In the smartnic-fw container, this value will already be set for you. Displaying device information with the \"dev\" subcommand This will show information about the device such as the build version, build date/time and temperature. root@smartnic-fw:/# sn-cli dev version Device Version Info DNA: 0x40020000012306a21c10c285 USR_ACCESS: 0x000086d3 (34515) BUILD_STATUS: 0x04130920 root@smartnic-fw:/# sn-cli dev temp Temperature Monitors FPGA SLR0: 45.551 (deg C) The USR_ACCESS value is typically the unique build pipeline number that produced the embedded FPGA bitfile. The BUILD_STATUS value holds an encoded date/time (Aug 30 at 05:32am) which is when the embedded FPGA bitfile build was started. The DNA value holds the factory programmed unique ID of the FPGA Inspecting and Configuring the CMAC (100G) Interfaces with the \"cmac\" subcommand Enable/Disable one or more (or all by default) 100G MAC interfaces using these commands: sn-cli cmac enable sn-cli cmac disable sn-cli cmac -p 0 enable sn-cli cmac -p 1 disable Enabling a CMAC interface allows frames to pass (Rx/Tx) at the MAC layer. These commands do not affect whether the underlying physical layer (PHY) is operational. Display the current MAC and PHY status of one or more (or all by default) 100G MAC interfaces using these commands: root@smartnic-fw:/# sn-cli cmac status CMAC0 Tx (MAC ENABLED/PHY UP) Rx (MAC ENABLED/PHY UP) CMAC1 Tx (MAC ENABLED/PHY UP) Rx (MAC ENABLED/PHY DOWN) In the example output above, CMAC0 PHY layer is UP in both the Tx and Rx directions. The MAC is fully enabled. This link is operational and should be passing packets normally. In the example output above, CMAC1 PHY layer is DOWN in the Rx (receive) direction. Possible causes for this are: * No QSFP28 plugged into 100G port 0 the U280 card * Wrong type of QSFP28 module plugged into 100G port 0 * 100G QSFP28 SR4 or LR4 modules are supported * Some 100G AOC or DACs are known to work * QSFP+ 40G modules are not supported * QSFP 5G modules are not supported * QSFP28 card improperly seated in the U280 card * Check if the QSFP28 module is inserted upside down and physically blocked from being fully inserted * Unplug/replug the module, ensuring that it is properly oriented and firmly seated * Fiber not properly inserted * Unplug/replug the fiber connection at each end * Far end is operating in 4x25G or 2x50G split mode * The smartnic platform does not support 4x25G or 2x50G mode * Only 100G mode is supported on each of the U280 100G interfaces * Configure far end in 100G mode * Far end has RS-FEC (Reed-Solomon Forward Error Correction) enabled * The smartnic platform does not support RS-FEC * Disable RS-FEC on the far end equipment A more detailed status can also be displayed using the --verbose option. Note that the --verbose option is a global option and thus must be positioned before the cmac subcommand. root@smartnic-fw:/# sn-cli --verbose cmac -p 1 status CMAC1 Tx (MAC ENABLED/PHY UP) tx_local_fault 0 Rx (MAC ENABLED/PHY DOWN) rx_got_signal_os 0 rx_bad_sfd 0 rx_bad_preamble 0 rx_test_pattern_mismatch 0 rx_received_local_fault 0 rx_internal_local_fault 1 rx_local_fault 1 rx_remote_fault 0 rx_hi_ber 0 rx_aligned_err 0 rx_misaligned 0 rx_aligned 0 rx_status 0 Display summary statistics for packets Rx'd and Tx'd from CMAC ports root@smartnic-fw:/# sn-cli cmac stats CMAC0: TX 0 RX 0 RX-DISC 0 RX-ERR 0 CMAC1: TX 0 RX 0 RX-DISC 0 RX-ERR 0 Note: The CMAC counters are only cleared/reset when the FPGA is reprogrammed. Inspecting and Configuring the PCIe Queue DMA (QDMA) block with the \"qdma\" subcommand The QDMA block is responsible for managing all DMA queues used for transferring packets and/or events bidirectionally between the U280 card and the Host CPU over the PCIe bus. In order for any DMA transfers to be allowed on either of the PCIe Physical Functions (PF), an appropriate number of DMA Queue IDs must be provisioned. This can be done using the qdma subcommand. Configure the number of queues allocated to each of the PCIe Physical Functions sn-cli qdma setqs 1 1 This assigns 1 QID to PF0 and 1 QIDs to PF1. The setqs subcommand also takes care of configuring the RSS entropy -> QID map with an equal weighted distribution of all allocated queues. If you're unsure of how many QIDs to allocate, using 1 1 here is your best choice. Inspect the configuration of the QDMA block sn-cli qdma status Packet, byte and error counters are tracked for packets heading between the QDMA engine and the user application. You can display them with this command: sn-cli qdma stats Refer to the open-nic-shell documentation for an explanation of exactly where in the FPGA design these statistics are measured. Inspecting packet counters in the smartnic platform with the \"probe\" subcommand The smartnic platform implements monitoring points in the datapath at various locations. You an inspect these counters using this command: sn-cli probe stats Refer to the esnet-smartnic-hw documentation for an explanation of exactly where in the FPGA design these statistics are measured. Configuring the smartnic platform ingress/egress/bypass switch port remapping functions with the \"sw\" subcommand The smartnic platform implements reconfigurable ingress and egress port remapping, connections and redirecting. You can inspect and modify these configuration points using the \"sw\" subcommand. Most of the sw subcommands take one or more port bindings as parameters. The port bindings are of the form: <port>:<port-connector> Where: * <port> is one of * cmac0 -- 100G port 0 * cmac1 -- 100G port 1 * host0 -- DMA over PCIe Physical Function 0 (PF0) * host1 -- DMA over PCIe Physical Function 1 (PF1) * <port-connector> is context dependent and is one of * cmac0 * cmac1 * host0 * host1 * bypass -- a high bandwidth channel through the smartnic which does NOT pass through the user's application * app0 -- user application port 0 (typically a p4 program ingress) * app1 -- user application port 1 (only available when user implements it in verilog) * drop -- infinite blackhole that discards all packets sent to it Display the current configuration status sn-cli sw status Remap/rename physical input ports to logical input ports The in-port-rename subcommand allows you to remap the identity of a smartnic platform physical ingress port to any logical port as seen by the user logic. Once remapped (eg. from a -> b ), all following logic in the smartnic will perceive that the packet arrived on ingress port b even though it physically arrived on port a . This can be useful for test injection scenarios but would typically be set to a straight-through mapping in production. sn-cli sw in-port-rename a:b To reset this mapping so each port maps to its usual identity: sn-cli sw in-port-rename cmac0:cmac0 cmac1:cmac1 host0:host0 host1:host1 Attach logical input ports to pipelines The in-port-connect subcommand allows you to connect a logical input port to different processing pipelines within the smartnic. This can be used to connect to a p4 program or to custom logic within the user application. It can also be used to shunt all packets to a blackhole or to bypass packets around the user application entirely. sn-cli sw in-port-connect cmac0:app0 cmac1:app0 host0:bypass host1:bypass Connect input ports to output ports in the bypass path The bypass-connect subcommand allows you to connect input ports directly to output ports as they pass through the bypass path (ie. not through the user application). This is useful for providing direct connectivity from host PCIe PFs to 100G CMAC interfaces for network testing. sn-cli sw bypass-connect host0:cmac0 host1:cmac1 cmac0:host0 cmac1:host1 NOTE any packets that follow the bypass path will not be processed by the user's p4 program Override user application output port decisions and redirect to an alternate port The app0-port-redirect and app1-port-redirect subcommands allow the user to override the forwarding decisions made by the user application and/or p4 program and redirect any given output port to a different output port. This can be useful during development/debugging and in test fixtures. NOTE there are separate overrides for the app0 outputs and the app1 outputs. sn-cli sw app0-port-redirect cmac0:host0 cmac1:host1 sn-cli sw app1-port-redirect cmac0:host0 cmac1:host1 To reset this mapping so each output ports maps to its usual destination: sn-cli sw app0-port-redirect cmac0:cmac0 cmac1:cmac1 host0:host0 host1:host1 sn-cli sw app1-port-redirect cmac0:cmac0 cmac1:cmac1 host0:host0 host1:host1 Using the sn-p4-cli tool The user's p4 application embedded within the smartnic design may have configurable lookup tables which are used during the wire-speed execution of the packet processing pipeline. The sn-p4-cli tool provides subcommands to help you to manage the rules in all of the lookup tables defined in your p4 program. All commands described below are expected to be executed within the smartnic-fw container environment. Use this command to enter the appropriate environment. docker compose exec smartnic-fw bash The sn-p4-cli tool will automatically look for an environment variable called SN_P4_CLI_SERVER which can be set to the hostname of the sn-p4-agent that will perform all of the requested actions on the real hardware. In the smartnic-fw container, this value will already be set for you. Inspecting the pipeline structure with the \"info\" subcommand The info subcommand is used to display the pipeline structure, including table names, match fields (and their types), action names and the list of parameters for each action. This information can be used to formulate new rule definitions for the other subcommands. sn-p4-cli info Inserting a new rule into a table The table-insert subcommand allows you to insert a new rule into a specified table. sn-p4-cli table-insert <table-name> <action-name> --match <match-expr> [--param <param-expr>] [--priority <prio-val>] Where: * <table-name> is the name of the table to be operated on * <action-name> is the action that you would like to activate when this rule matches * <match-expr> is one or more match expressions which collectively define when this rule should match a given packet * The number and type of the match fields depends on the p4 definition of the table * The --match option may be specified multiple times and all match-expr s will be concatenated * <param-expr> is one or more parameter values which will be returned as a result when this rule matches a given packet * The number and type of the action parameters depends on the p4 definition of the action within the table * Some actions require zero parameters. In this case, omit the optional --param option entirely. * <prio-val> is the priority to be used to resolve scenarios where multiple matches could occur * The --priority option is required for tables with CAM/TCAM type matches (prefix/range/ternary) * The --priority option is prohibited for tables without CAM/TCAM type mathes NOTE : You can find details about your pipeline structure and valid names by running the info subcommand. Updating an existing rule within a table The table-update subcommand allows you to update the action and parameters for an existing rule within a table sn-p4-cli table-update <table-name> <new-action-name> --match <match-expr> [--param <new-param-expr>] Where: * <table-name> is the table containing the rule to be updated * <new-action-name> is the new action that should be applied when this rule matches * <match-expr> is the exact original <match-expr> used when the original rule was inserted * <new-param-expr> is the set of new parameters to be returned when this rule matches * NOTE : the new parameters must be consistent with the new action Removing previously inserted rules The clear-all and table-clear and table-delete subcommands allow you to remove rules from tables with varying precision. Clear all rules from all tables in the pipeline. sn-p4-cli clear-all` Clear all rules from a single specified table. sn-p4-cli table-clear <table-name> Remove a specific rule from a specific table. table-delete <table-name> --match <match-expr> Bulk changes of rules using a p4bm simulator rules file Using the the p4bm-apply subcommand, a list of pipeline modifications can be applied from a file. A subset of the full p4bm simulator file format is supported by the sn-p4-cli command. sn-p4-cli p4bm-apply <filename> Supported actions within the p4bm file are: * table_insert <table-name> <action-name> <match-expr> => <param-expr> [priority] * Insert a rule * clear_all * Clear all rules from all tables * table_clear <table-name> * Clear all rules from a specified table All comment characters # and text following them up to the end of the line are ignored. Stopping the runtime environment When we're finished using the smartnic runtime environment, we can stop and remove our docker containers. docker compose down -v Using the smartnic-dpdk container The sn-stack environment can be started in a mode where the FPGA can be controlled by a DPDK application. Running in this mode requires a few carefully ordered steps. Broadly speaking, the steps required to bring up a DPDK application are as follows: * Bind the vfio-pci kernel driver to each FPGA PCIe physical function (PF) * This is handled automatically by the sn-stack. * Run a DPDK application with appropriate DPDK Environment Abstraction Layer (EAL) settings * Use -a $SN_PCIE_DEV.0 to allow control of one or more specific FPGA PCIe PFs * Use -d librte_net_qdma.so to dynamically link the correct Userspace Polled-Mode Driver (PMD) for the smartnic QDMA engine * The EAL will * Open the PCIe PFs using the kernel's vfio-pci driver * Take the FPGA device out of reset * Open and map large memory regions for DMA using the kernel's hugepages driver * The application is responsible for assigning buffers to one or more of the FPGA's DMA queues * Use the sn-cli tool to configure some of the low-level hardware components in the FPGA * Configure the set of valid DMA queues in the FPGA (must match what is set in the DPDK application) * Bring up the physical ethernet ports In the examples below, we will be running the pktgen-dpdk application to control packet tx/rx via the FPGA's PCIe physical functions. This can be very useful for injecting packets into a design for testing behaviour on real hardware. For more information about DPDK in general, see: * http://core.dpdk.org/doc/ For more information about the pktgen-dpdk application, see: * https://pktgen-dpdk.readthedocs.io/en/latest/index.html Before you bring up the sn-stack , please ensure that you have uncommented this line in your .env file COMPOSE_PROFILES=smartnic-dpdk If you changed this while the stack was already running, you'll need to restart the stack with down/up. First, you'll need to start up the pktgen application to open the vfio-pci device for PF0 and PF1 and take the FPGA out of reset. $ docker compose exec smartnic-dpdk bash root@smartnic-dpdk:/# pktgen -a $SN_PCIE_DEV.0 -a $SN_PCIE_DEV.1 -l 4-8 -n 4 -d librte_net_qdma.so --file-prefix $SN_PCIE_DEV- -- -v -m [5:6].0 -m [7:8].1 Pktgen:/> help NOTE: Leave this application running while doing the remaining setup steps. The setup steps below must be re-run after each time you restart the pktgen application since the FPGA gets reset between runs. Open a separate shell window which you will use for doing the low-level smartnic platform configuration. Configure the Queue mappings for host PF0 and PF1 interfaces and bring up the physical ethernet ports using the smartnic-fw container. $ docker compose exec smartnic-fw bash root@smartnic-fw:/# sn-cli qdma setqs 1 1 root@smartnic-fw:/# sn-cli qdma status root@smartnic-fw:/# sn-cli cmac enable root@smartnic-fw:/# sn-cli cmac status Setting up the queue mappings tells the smartnic platform which QDMA queues to use for h2c and c2h packets. Enabling the CMACs allows Rx and Tx packets to flow (look for MAC ENABLED/PHY UP ). In this lesson, you will follow simple steps that allow you to use DPDK and pktgen to interact with the P4 program that you have loaded onto the FPGA. Advanced usage of the pktgen-dpdk application Example of streaming packets out of an interface from a pcap file rather than generating the packets within the UI. Note the -s <P>:file.pcap option where P refers to the port number to bind the pcap file to. root@smartnic-dpdk:/# pktgen -a $SN_PCIE_DEV.0 -a $SN_PCIE_DEV.1 -l 4-8 -n 4 -d librte_net_qdma.so --file-prefix $SN_PCIE_DEV- -- -v -m [5:6].0 -m [7:8].1 -s 1:your_custom.pcap Pktgen:/> port 1 Pktgen:/> page pcap Pktgen:/> page main Pktgen:/> start 1 Pktgen:/> stop 1 Pktgen:/> clr Example of running a particular test case via a script rather than typing at the UI cat <<_EOF > /tmp/test.pkt clr set 1 size 1400 set 1 count 1000000 enable 0 capture start 1 disable 0 capture _EOF root@smartnic-dpdk:/# pktgen -a $SN_PCIE_DEV.0 -a SN_PCIE_DEV.1 -l 4-8 -n 4 -d librte_net_qdma.so --file-prefix $SN_PCIE_DEV- -- -v -m [5:6].0 -m [7:8].1 -f /tmp/test.pkt Troubleshooting the pktgen-dpdk Application If pktgen isn't starting, please consider the following troubleshooting steps: Ensure you are using the correct profile in your sn-stack/.env file and that you are starting pktgen with the right command. For a more detailed understanding of the command, please refer to the pktgen documentation provided earlier. If pktgen is starting, but packets aren't flowing as expected, you can check the packet path using the following command inside the smartnic-fw container: sn-cli probe stats If packets sent to/from the host aren't achieving line rate (100Gbps per port), it could be due to QDMA queue allocation. You can attempt to allocate more QDMA queues per port by setting sn-cli qdma setqs to values higher than 1 1 . If packets are egressing to the wrong port (whether CMAC or PF), it might be due to the sn-cli configuration. For example, here's a script that routes all egress packets to CMAC1: #!/bin/bash sn-cli dev version sn-cli sw in-port-rename cmac0:cmac0 cmac1:cmac1 host0:host0 host1:host1 sn-cli sw app0-port-redirect cmac0:cmac0 cmac1:cmac1 host0:host0 host1:host1 sn-cli sw app1-port-redirect cmac0:cmac0 cmac1:cmac1 host0:host0 host1:host1 sn-cli sw bypass-connect cmac0:cmac0 cmac1:cmac1 host0:host0 host1:host1 sn-cli sw in-port-connect cmac0:app0 cmac1:app0 host0:app0 host1:app0 sn-cli sw status sn-cli qdma setqs 1 1 sn-cli cmac enable sn-cli cmac status These steps should help you troubleshoot issues related to the pktgen-dpdk application effectively. References This tutorial is built on the following software/respositories along with versions/commits: Ubuntu 20.04 with Linux 5.4.0-153. Vivado 2023.1 with the VitisNetowrkingP4 license. The esnet-smartnic-hw repository (commit: 9ee2cbb). The esnet-smartnic-fw repository (commit: 180595c). The smartnic-dpdk-docker repository (commit: a52dba3). The xilinx-labtools-docker repository (commit: 84cf05f). Known Issues None to date. If you face any issues, please contact mailto:cs595-f2023-group@iit.edu Conclusion Congratulations! You've successfully set up Xilinx Alveo FPGAs as SmartNICs using the ESnet framework. This powerful combination opens doors to accelerated network processing and customization. Feel free to explore further, experiment, and innovate with FPGA-based SmartNIC solutions. For more information, visit the official ESnet repositories: - esnet-smartnic-hw - esnet-smartnic-fw - smartnic-dpdk-docker - xilinx-labtools-docker Happy networking!","title":"Lesson 4"},{"location":"4-lesson4/#lesson-4-running-the-deployment","text":"","title":"Lesson 4: Running the Deployment"},{"location":"4-lesson4/#converting-from-factory-flash-image-to-esnet-smartnic-flash-image","text":"From the factory, the FPGA cards have only a \"gold\" bitfile in flash with the \"user\" partition of flash being blank. The \"gold\" bitfile has a narrow PCIe memory window for BAR1 and BAR2 which is insufficient for the ESnet Smartnic platform. Fixing this requires a one-time flash programming step to install an ESnet Smartnic bitfile into the FPGA \"user\" partition in flash. This initial setup is done using the JTAG. Ensure that any running sn-stack instances have been stopped so that they don't interfere with the flash programming operation. docker compose down -v --remove-orphans Start the flash rescue service to program an ESnet Smartnic bitfile into the FPGA card \"user\" partition using the JTAG interface. This takes approximately 20 minutes. This process should not be interrupted. docker compose --profile smartnic-flash run --rm smartnic-flash-rescue This will: * Use JTAG to write a small flash-programing helper bitfile into the FPGA * Use JTAG to write the current version of the bitfile into the FPGA card's \"user\" partition in flash * Only the \"user\" partition of the flash is overwritten by this step * The \"gold\" partition is left untouched Clean up by bringing down the running stack after flash writing has completed. docker compose down -v --remove-orphans Perform a cold-boot (power cycle) of the server hosting the FPGA card It is essential that this is a proper power cycle and not simply a warm reboot. Specifically do not use shutdown -r now but rather use something like ipmitool chassis power cycle . Failure to perform a cold-boot here will result in an unusable card.","title":"Converting from factory flash image to ESnet Smartnic flash image"},{"location":"4-lesson4/#normal-operation-of-the-runtime-environment","text":"","title":"Normal Operation of the Runtime Environment"},{"location":"4-lesson4/#running-the-firmware","text":"Start up the full firmware docker stack like this docker compose up -d","title":"Running the firmware"},{"location":"4-lesson4/#verifying-the-bitfile-download","text":"docker compose logs smartnic-hw","title":"Verifying the bitfile download"},{"location":"4-lesson4/#inspecting-registers-and-interacting-with-the-firmware","text":"The firmware runtime environment exists inside of the smartnic-fw container. Here, we exec a shell inside of that container and have a look around. docker compose exec smartnic-fw bash sn-cli dev version regio syscfg If this prints wrong values or all ones, make sure you don\u2019t have the COMPOSE_PROFILES set to smartnic-mgr-dpdk-manual in your sn-stack/.env file. Otherwise, you will not be able to access any sn-cli tools unless pktgen is running.","title":"Inspecting registers and interacting with the firmware"},{"location":"4-lesson4/#optional-updating-the-flash-image-to-a-new-esnet-smartnic-flash-image","text":"The instructions in this section are used to update the Smartnic flash image from an already working Smartnic environment. This update step is optional and only required if you want to change the contents of the FPGA card flash. Normally, the \"RAM\" of the FPGA is loaded using JTAG during stack startup. NOTE This will not work for the very first time ever programming the flash. See \"Converting from factory flash image to ESnet Smartnic flash image\" section above for first-time setup. Start up a any properly configured stack which will allow us to write the flash using a fast algorithm over PCIe. docker compose up -d Confirm that PCIe register IO is working in your stack by querying the version registers. docker compose exec smartnic-fw sn-cli dev version Confirm that the \"DNA\" register is not showing 0xfffff... as its contents. Start the flash update service to write the currently active FPGA bitfile into the persistent flash on the FPGA card. This takes approximately 7-8 minutes. This process should not be interrupted. docker compose --profile smartnic-flash run --rm smartnic-flash-update Bring down the running stack after flash writing has completed. docker compose down -v --remove-orphans","title":"(OPTIONAL) Updating the flash image to a new ESnet Smartnic flash image"},{"location":"4-lesson4/#optional-remove-the-esnet-smartnic-flash-image-from-the-fpga-card-to-revert-to-factory-image","text":"The instructions in this section are used to remove the Smartnic flash image from an already working Smartnic environment. This removal step is optional and only required if you want to reset the contents of the FPGA card flash back to the factory bitfile. If you want to keep using the card as an ESnet Smartnic, do not perform these operations or you'll have to re-do the \"Converting from factory flash image to ESnet Smartnic flash image\" section above. Start up a any properly configured stack which will allow us to write the flash using a fast algorithm over PCIe. docker compose up -d Confirm that PCIe register IO is working in your stack by querying the version registers. docker compose exec smartnic-fw sn-cli dev version Confirm that the \"DNA\" register is not showing 0xfffff... as its contents. Start the flash remove service to erase the ESnet Smartnic image from the \"user\" partition of the FPGA card flash. This takes less than 1 minute. This process should not be interrupted. docker compose --profile smartnic-flash run --rm smartnic-flash-remove Bring down the running stack after flash reset is completed. docker compose down -v --remove-orphans Note: If you want to flash the golden (recovery) image and it is not working, you can use vivado_lab with the following commands: vivado_lab \\ -nolog \\ -nojournal \\ -tempDir /tmp/ \\ -mode batch \\ -notrace \\ -quiet \\ -source /scripts/program_flash.tcl \\ -tclargs \"$HW_SERVER_URL\" \"$HW_TARGET_SERIAL\" \"/scripts/revert_to_golden.mcs\" If you don't know how to set it up, you can go to sn-stack/smartnic-hw/scripts and put the \"revert to golden\" image there. For more information on how to get the golden image, you can refer to this link . After placing the image there, you can modify the program_flash.sh script and change: vivado_lab \\ -nolog \\ -nojournal \\ -tempDir /tmp/ \\ -mode batch \\ -notrace \\ -quiet \\ -source /scripts/program_flash.tcl \\ -tclargs \"$HW_SERVER_URL\" \"$HW_TARGET_SERIAL\" \"$MCSFILE_PATH To: vivado_lab \\ -nolog \\ -nojournal \\ -tempDir /tmp/ \\ -mode batch \\ -notrace \\ -quiet \\ -source /scripts/program_flash.tcl \\ -tclargs \"$HW_SERVER_URL\" \"$HW_TARGET_SERIAL\" \"/scripts/revert_to_golden.mcs\" After a cold reboot, you will see the cards are back to the golden image. Important notice: The golden image will not make the cards appear in XRT, as XRT needs an \"XRT-friendly\" shell. However, it'll make xbmgmt see the card, and from there, you can flash a new platform that works with XRT. For more info on the golden image, you can refer to this documentation .","title":"(OPTIONAL) Remove the ESnet Smartnic flash image from the FPGA card to revert to factory image"},{"location":"4-lesson4/#using-the-sn-cli-tool","text":"The sn-cli tool provides subcommands to help you accomplish many common tasks for inspecting and configuring the smartnic platform components. All commands described below are expected to be executed within the smartnic-fw container environment. Use this command to enter the appropriate environment. docker compose exec smartnic-fw bash The sn-cli tool will automatically look for an environment variable called SN_CLI_SLOTADDR which can be set to the PCIe BDF address of the device that you would like to interract with. In the smartnic-fw container, this value will already be set for you.","title":"Using the sn-cli tool"},{"location":"4-lesson4/#displaying-device-information-with-the-dev-subcommand","text":"This will show information about the device such as the build version, build date/time and temperature. root@smartnic-fw:/# sn-cli dev version Device Version Info DNA: 0x40020000012306a21c10c285 USR_ACCESS: 0x000086d3 (34515) BUILD_STATUS: 0x04130920 root@smartnic-fw:/# sn-cli dev temp Temperature Monitors FPGA SLR0: 45.551 (deg C) The USR_ACCESS value is typically the unique build pipeline number that produced the embedded FPGA bitfile. The BUILD_STATUS value holds an encoded date/time (Aug 30 at 05:32am) which is when the embedded FPGA bitfile build was started. The DNA value holds the factory programmed unique ID of the FPGA","title":"Displaying device information with the \"dev\" subcommand"},{"location":"4-lesson4/#inspecting-and-configuring-the-cmac-100g-interfaces-with-the-cmac-subcommand","text":"Enable/Disable one or more (or all by default) 100G MAC interfaces using these commands: sn-cli cmac enable sn-cli cmac disable sn-cli cmac -p 0 enable sn-cli cmac -p 1 disable Enabling a CMAC interface allows frames to pass (Rx/Tx) at the MAC layer. These commands do not affect whether the underlying physical layer (PHY) is operational. Display the current MAC and PHY status of one or more (or all by default) 100G MAC interfaces using these commands: root@smartnic-fw:/# sn-cli cmac status CMAC0 Tx (MAC ENABLED/PHY UP) Rx (MAC ENABLED/PHY UP) CMAC1 Tx (MAC ENABLED/PHY UP) Rx (MAC ENABLED/PHY DOWN) In the example output above, CMAC0 PHY layer is UP in both the Tx and Rx directions. The MAC is fully enabled. This link is operational and should be passing packets normally. In the example output above, CMAC1 PHY layer is DOWN in the Rx (receive) direction. Possible causes for this are: * No QSFP28 plugged into 100G port 0 the U280 card * Wrong type of QSFP28 module plugged into 100G port 0 * 100G QSFP28 SR4 or LR4 modules are supported * Some 100G AOC or DACs are known to work * QSFP+ 40G modules are not supported * QSFP 5G modules are not supported * QSFP28 card improperly seated in the U280 card * Check if the QSFP28 module is inserted upside down and physically blocked from being fully inserted * Unplug/replug the module, ensuring that it is properly oriented and firmly seated * Fiber not properly inserted * Unplug/replug the fiber connection at each end * Far end is operating in 4x25G or 2x50G split mode * The smartnic platform does not support 4x25G or 2x50G mode * Only 100G mode is supported on each of the U280 100G interfaces * Configure far end in 100G mode * Far end has RS-FEC (Reed-Solomon Forward Error Correction) enabled * The smartnic platform does not support RS-FEC * Disable RS-FEC on the far end equipment A more detailed status can also be displayed using the --verbose option. Note that the --verbose option is a global option and thus must be positioned before the cmac subcommand. root@smartnic-fw:/# sn-cli --verbose cmac -p 1 status CMAC1 Tx (MAC ENABLED/PHY UP) tx_local_fault 0 Rx (MAC ENABLED/PHY DOWN) rx_got_signal_os 0 rx_bad_sfd 0 rx_bad_preamble 0 rx_test_pattern_mismatch 0 rx_received_local_fault 0 rx_internal_local_fault 1 rx_local_fault 1 rx_remote_fault 0 rx_hi_ber 0 rx_aligned_err 0 rx_misaligned 0 rx_aligned 0 rx_status 0 Display summary statistics for packets Rx'd and Tx'd from CMAC ports root@smartnic-fw:/# sn-cli cmac stats CMAC0: TX 0 RX 0 RX-DISC 0 RX-ERR 0 CMAC1: TX 0 RX 0 RX-DISC 0 RX-ERR 0 Note: The CMAC counters are only cleared/reset when the FPGA is reprogrammed.","title":"Inspecting and Configuring the CMAC (100G) Interfaces with the \"cmac\" subcommand"},{"location":"4-lesson4/#inspecting-and-configuring-the-pcie-queue-dma-qdma-block-with-the-qdma-subcommand","text":"The QDMA block is responsible for managing all DMA queues used for transferring packets and/or events bidirectionally between the U280 card and the Host CPU over the PCIe bus. In order for any DMA transfers to be allowed on either of the PCIe Physical Functions (PF), an appropriate number of DMA Queue IDs must be provisioned. This can be done using the qdma subcommand. Configure the number of queues allocated to each of the PCIe Physical Functions sn-cli qdma setqs 1 1 This assigns 1 QID to PF0 and 1 QIDs to PF1. The setqs subcommand also takes care of configuring the RSS entropy -> QID map with an equal weighted distribution of all allocated queues. If you're unsure of how many QIDs to allocate, using 1 1 here is your best choice. Inspect the configuration of the QDMA block sn-cli qdma status Packet, byte and error counters are tracked for packets heading between the QDMA engine and the user application. You can display them with this command: sn-cli qdma stats Refer to the open-nic-shell documentation for an explanation of exactly where in the FPGA design these statistics are measured.","title":"Inspecting and Configuring the PCIe Queue DMA (QDMA) block with the \"qdma\" subcommand"},{"location":"4-lesson4/#inspecting-packet-counters-in-the-smartnic-platform-with-the-probe-subcommand","text":"The smartnic platform implements monitoring points in the datapath at various locations. You an inspect these counters using this command: sn-cli probe stats Refer to the esnet-smartnic-hw documentation for an explanation of exactly where in the FPGA design these statistics are measured.","title":"Inspecting packet counters in the smartnic platform with the \"probe\" subcommand"},{"location":"4-lesson4/#configuring-the-smartnic-platform-ingressegressbypass-switch-port-remapping-functions-with-the-sw-subcommand","text":"The smartnic platform implements reconfigurable ingress and egress port remapping, connections and redirecting. You can inspect and modify these configuration points using the \"sw\" subcommand. Most of the sw subcommands take one or more port bindings as parameters. The port bindings are of the form: <port>:<port-connector> Where: * <port> is one of * cmac0 -- 100G port 0 * cmac1 -- 100G port 1 * host0 -- DMA over PCIe Physical Function 0 (PF0) * host1 -- DMA over PCIe Physical Function 1 (PF1) * <port-connector> is context dependent and is one of * cmac0 * cmac1 * host0 * host1 * bypass -- a high bandwidth channel through the smartnic which does NOT pass through the user's application * app0 -- user application port 0 (typically a p4 program ingress) * app1 -- user application port 1 (only available when user implements it in verilog) * drop -- infinite blackhole that discards all packets sent to it","title":"Configuring the smartnic platform ingress/egress/bypass switch port remapping functions with the \"sw\" subcommand"},{"location":"4-lesson4/#display-the-current-configuration-status","text":"sn-cli sw status","title":"Display the current configuration status"},{"location":"4-lesson4/#remaprename-physical-input-ports-to-logical-input-ports","text":"The in-port-rename subcommand allows you to remap the identity of a smartnic platform physical ingress port to any logical port as seen by the user logic. Once remapped (eg. from a -> b ), all following logic in the smartnic will perceive that the packet arrived on ingress port b even though it physically arrived on port a . This can be useful for test injection scenarios but would typically be set to a straight-through mapping in production. sn-cli sw in-port-rename a:b To reset this mapping so each port maps to its usual identity: sn-cli sw in-port-rename cmac0:cmac0 cmac1:cmac1 host0:host0 host1:host1","title":"Remap/rename physical input ports to logical input ports"},{"location":"4-lesson4/#attach-logical-input-ports-to-pipelines","text":"The in-port-connect subcommand allows you to connect a logical input port to different processing pipelines within the smartnic. This can be used to connect to a p4 program or to custom logic within the user application. It can also be used to shunt all packets to a blackhole or to bypass packets around the user application entirely. sn-cli sw in-port-connect cmac0:app0 cmac1:app0 host0:bypass host1:bypass","title":"Attach logical input ports to pipelines"},{"location":"4-lesson4/#connect-input-ports-to-output-ports-in-the-bypass-path","text":"The bypass-connect subcommand allows you to connect input ports directly to output ports as they pass through the bypass path (ie. not through the user application). This is useful for providing direct connectivity from host PCIe PFs to 100G CMAC interfaces for network testing. sn-cli sw bypass-connect host0:cmac0 host1:cmac1 cmac0:host0 cmac1:host1 NOTE any packets that follow the bypass path will not be processed by the user's p4 program","title":"Connect input ports to output ports in the bypass path"},{"location":"4-lesson4/#override-user-application-output-port-decisions-and-redirect-to-an-alternate-port","text":"The app0-port-redirect and app1-port-redirect subcommands allow the user to override the forwarding decisions made by the user application and/or p4 program and redirect any given output port to a different output port. This can be useful during development/debugging and in test fixtures. NOTE there are separate overrides for the app0 outputs and the app1 outputs. sn-cli sw app0-port-redirect cmac0:host0 cmac1:host1 sn-cli sw app1-port-redirect cmac0:host0 cmac1:host1 To reset this mapping so each output ports maps to its usual destination: sn-cli sw app0-port-redirect cmac0:cmac0 cmac1:cmac1 host0:host0 host1:host1 sn-cli sw app1-port-redirect cmac0:cmac0 cmac1:cmac1 host0:host0 host1:host1","title":"Override user application output port decisions and redirect to an alternate port"},{"location":"4-lesson4/#using-the-sn-p4-cli-tool","text":"The user's p4 application embedded within the smartnic design may have configurable lookup tables which are used during the wire-speed execution of the packet processing pipeline. The sn-p4-cli tool provides subcommands to help you to manage the rules in all of the lookup tables defined in your p4 program. All commands described below are expected to be executed within the smartnic-fw container environment. Use this command to enter the appropriate environment. docker compose exec smartnic-fw bash The sn-p4-cli tool will automatically look for an environment variable called SN_P4_CLI_SERVER which can be set to the hostname of the sn-p4-agent that will perform all of the requested actions on the real hardware. In the smartnic-fw container, this value will already be set for you.","title":"Using the sn-p4-cli tool"},{"location":"4-lesson4/#inspecting-the-pipeline-structure-with-the-info-subcommand","text":"The info subcommand is used to display the pipeline structure, including table names, match fields (and their types), action names and the list of parameters for each action. This information can be used to formulate new rule definitions for the other subcommands. sn-p4-cli info","title":"Inspecting the pipeline structure with the \"info\" subcommand"},{"location":"4-lesson4/#inserting-a-new-rule-into-a-table","text":"The table-insert subcommand allows you to insert a new rule into a specified table. sn-p4-cli table-insert <table-name> <action-name> --match <match-expr> [--param <param-expr>] [--priority <prio-val>] Where: * <table-name> is the name of the table to be operated on * <action-name> is the action that you would like to activate when this rule matches * <match-expr> is one or more match expressions which collectively define when this rule should match a given packet * The number and type of the match fields depends on the p4 definition of the table * The --match option may be specified multiple times and all match-expr s will be concatenated * <param-expr> is one or more parameter values which will be returned as a result when this rule matches a given packet * The number and type of the action parameters depends on the p4 definition of the action within the table * Some actions require zero parameters. In this case, omit the optional --param option entirely. * <prio-val> is the priority to be used to resolve scenarios where multiple matches could occur * The --priority option is required for tables with CAM/TCAM type matches (prefix/range/ternary) * The --priority option is prohibited for tables without CAM/TCAM type mathes NOTE : You can find details about your pipeline structure and valid names by running the info subcommand.","title":"Inserting a new rule into a table"},{"location":"4-lesson4/#updating-an-existing-rule-within-a-table","text":"The table-update subcommand allows you to update the action and parameters for an existing rule within a table sn-p4-cli table-update <table-name> <new-action-name> --match <match-expr> [--param <new-param-expr>] Where: * <table-name> is the table containing the rule to be updated * <new-action-name> is the new action that should be applied when this rule matches * <match-expr> is the exact original <match-expr> used when the original rule was inserted * <new-param-expr> is the set of new parameters to be returned when this rule matches * NOTE : the new parameters must be consistent with the new action","title":"Updating an existing rule within a table"},{"location":"4-lesson4/#removing-previously-inserted-rules","text":"The clear-all and table-clear and table-delete subcommands allow you to remove rules from tables with varying precision. Clear all rules from all tables in the pipeline. sn-p4-cli clear-all` Clear all rules from a single specified table. sn-p4-cli table-clear <table-name> Remove a specific rule from a specific table. table-delete <table-name> --match <match-expr>","title":"Removing previously inserted rules"},{"location":"4-lesson4/#bulk-changes-of-rules-using-a-p4bm-simulator-rules-file","text":"Using the the p4bm-apply subcommand, a list of pipeline modifications can be applied from a file. A subset of the full p4bm simulator file format is supported by the sn-p4-cli command. sn-p4-cli p4bm-apply <filename> Supported actions within the p4bm file are: * table_insert <table-name> <action-name> <match-expr> => <param-expr> [priority] * Insert a rule * clear_all * Clear all rules from all tables * table_clear <table-name> * Clear all rules from a specified table All comment characters # and text following them up to the end of the line are ignored.","title":"Bulk changes of rules using a p4bm simulator rules file"},{"location":"4-lesson4/#stopping-the-runtime-environment","text":"When we're finished using the smartnic runtime environment, we can stop and remove our docker containers. docker compose down -v","title":"Stopping the runtime environment"},{"location":"4-lesson4/#using-the-smartnic-dpdk-container","text":"The sn-stack environment can be started in a mode where the FPGA can be controlled by a DPDK application. Running in this mode requires a few carefully ordered steps. Broadly speaking, the steps required to bring up a DPDK application are as follows: * Bind the vfio-pci kernel driver to each FPGA PCIe physical function (PF) * This is handled automatically by the sn-stack. * Run a DPDK application with appropriate DPDK Environment Abstraction Layer (EAL) settings * Use -a $SN_PCIE_DEV.0 to allow control of one or more specific FPGA PCIe PFs * Use -d librte_net_qdma.so to dynamically link the correct Userspace Polled-Mode Driver (PMD) for the smartnic QDMA engine * The EAL will * Open the PCIe PFs using the kernel's vfio-pci driver * Take the FPGA device out of reset * Open and map large memory regions for DMA using the kernel's hugepages driver * The application is responsible for assigning buffers to one or more of the FPGA's DMA queues * Use the sn-cli tool to configure some of the low-level hardware components in the FPGA * Configure the set of valid DMA queues in the FPGA (must match what is set in the DPDK application) * Bring up the physical ethernet ports In the examples below, we will be running the pktgen-dpdk application to control packet tx/rx via the FPGA's PCIe physical functions. This can be very useful for injecting packets into a design for testing behaviour on real hardware. For more information about DPDK in general, see: * http://core.dpdk.org/doc/ For more information about the pktgen-dpdk application, see: * https://pktgen-dpdk.readthedocs.io/en/latest/index.html Before you bring up the sn-stack , please ensure that you have uncommented this line in your .env file COMPOSE_PROFILES=smartnic-dpdk If you changed this while the stack was already running, you'll need to restart the stack with down/up. First, you'll need to start up the pktgen application to open the vfio-pci device for PF0 and PF1 and take the FPGA out of reset. $ docker compose exec smartnic-dpdk bash root@smartnic-dpdk:/# pktgen -a $SN_PCIE_DEV.0 -a $SN_PCIE_DEV.1 -l 4-8 -n 4 -d librte_net_qdma.so --file-prefix $SN_PCIE_DEV- -- -v -m [5:6].0 -m [7:8].1 Pktgen:/> help NOTE: Leave this application running while doing the remaining setup steps. The setup steps below must be re-run after each time you restart the pktgen application since the FPGA gets reset between runs. Open a separate shell window which you will use for doing the low-level smartnic platform configuration. Configure the Queue mappings for host PF0 and PF1 interfaces and bring up the physical ethernet ports using the smartnic-fw container. $ docker compose exec smartnic-fw bash root@smartnic-fw:/# sn-cli qdma setqs 1 1 root@smartnic-fw:/# sn-cli qdma status root@smartnic-fw:/# sn-cli cmac enable root@smartnic-fw:/# sn-cli cmac status Setting up the queue mappings tells the smartnic platform which QDMA queues to use for h2c and c2h packets. Enabling the CMACs allows Rx and Tx packets to flow (look for MAC ENABLED/PHY UP ). In this lesson, you will follow simple steps that allow you to use DPDK and pktgen to interact with the P4 program that you have loaded onto the FPGA.","title":"Using the smartnic-dpdk container"},{"location":"4-lesson4/#advanced-usage-of-the-pktgen-dpdk-application","text":"Example of streaming packets out of an interface from a pcap file rather than generating the packets within the UI. Note the -s <P>:file.pcap option where P refers to the port number to bind the pcap file to. root@smartnic-dpdk:/# pktgen -a $SN_PCIE_DEV.0 -a $SN_PCIE_DEV.1 -l 4-8 -n 4 -d librte_net_qdma.so --file-prefix $SN_PCIE_DEV- -- -v -m [5:6].0 -m [7:8].1 -s 1:your_custom.pcap Pktgen:/> port 1 Pktgen:/> page pcap Pktgen:/> page main Pktgen:/> start 1 Pktgen:/> stop 1 Pktgen:/> clr Example of running a particular test case via a script rather than typing at the UI cat <<_EOF > /tmp/test.pkt clr set 1 size 1400 set 1 count 1000000 enable 0 capture start 1 disable 0 capture _EOF root@smartnic-dpdk:/# pktgen -a $SN_PCIE_DEV.0 -a SN_PCIE_DEV.1 -l 4-8 -n 4 -d librte_net_qdma.so --file-prefix $SN_PCIE_DEV- -- -v -m [5:6].0 -m [7:8].1 -f /tmp/test.pkt","title":"Advanced usage of the pktgen-dpdk application"},{"location":"4-lesson4/#troubleshooting-the-pktgen-dpdk-application","text":"If pktgen isn't starting, please consider the following troubleshooting steps: Ensure you are using the correct profile in your sn-stack/.env file and that you are starting pktgen with the right command. For a more detailed understanding of the command, please refer to the pktgen documentation provided earlier. If pktgen is starting, but packets aren't flowing as expected, you can check the packet path using the following command inside the smartnic-fw container: sn-cli probe stats If packets sent to/from the host aren't achieving line rate (100Gbps per port), it could be due to QDMA queue allocation. You can attempt to allocate more QDMA queues per port by setting sn-cli qdma setqs to values higher than 1 1 . If packets are egressing to the wrong port (whether CMAC or PF), it might be due to the sn-cli configuration. For example, here's a script that routes all egress packets to CMAC1: #!/bin/bash sn-cli dev version sn-cli sw in-port-rename cmac0:cmac0 cmac1:cmac1 host0:host0 host1:host1 sn-cli sw app0-port-redirect cmac0:cmac0 cmac1:cmac1 host0:host0 host1:host1 sn-cli sw app1-port-redirect cmac0:cmac0 cmac1:cmac1 host0:host0 host1:host1 sn-cli sw bypass-connect cmac0:cmac0 cmac1:cmac1 host0:host0 host1:host1 sn-cli sw in-port-connect cmac0:app0 cmac1:app0 host0:app0 host1:app0 sn-cli sw status sn-cli qdma setqs 1 1 sn-cli cmac enable sn-cli cmac status These steps should help you troubleshoot issues related to the pktgen-dpdk application effectively.","title":"Troubleshooting the pktgen-dpdk Application"},{"location":"4-lesson4/#references","text":"This tutorial is built on the following software/respositories along with versions/commits: Ubuntu 20.04 with Linux 5.4.0-153. Vivado 2023.1 with the VitisNetowrkingP4 license. The esnet-smartnic-hw repository (commit: 9ee2cbb). The esnet-smartnic-fw repository (commit: 180595c). The smartnic-dpdk-docker repository (commit: a52dba3). The xilinx-labtools-docker repository (commit: 84cf05f).","title":"References"},{"location":"4-lesson4/#known-issues","text":"None to date. If you face any issues, please contact mailto:cs595-f2023-group@iit.edu","title":"Known Issues"},{"location":"4-lesson4/#conclusion","text":"Congratulations! You've successfully set up Xilinx Alveo FPGAs as SmartNICs using the ESnet framework. This powerful combination opens doors to accelerated network processing and customization. Feel free to explore further, experiment, and innovate with FPGA-based SmartNIC solutions. For more information, visit the official ESnet repositories: - esnet-smartnic-hw - esnet-smartnic-fw - smartnic-dpdk-docker - xilinx-labtools-docker Happy networking!","title":"Conclusion"},{"location":"LICENSE_ESNET/","text":"License Agreement ESnet SmartNIC Copyright (c) 2022, The Regents of the University of California, through Lawrence Berkeley National Laboratory (subject to receipt of any required approvals from the U.S. Dept. of Energy), 12574861 Canada Inc., Malleable Networks Inc., and Apical Networks, Inc. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: (1) Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. (2) Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. (3) Neither the name of the University of California, Lawrence Berkeley National Laboratory, U.S. Dept. of Energy, 12574861 Canada Inc., Malleable Networks Inc., and Apical Networks, Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. You are under no obligation whatsoever to provide any bug fixes, patches, or upgrades to the features, functionality or performance of the source code (\"Enhancements\") to anyone; however, if you choose to make your Enhancements available either publicly, or directly to Lawrence Berkeley National Laboratory, without imposing a separate written license agreement for such Enhancements, then you hereby grant the following license: a non-exclusive, royalty-free perpetual license to install, use, modify, prepare derivative works, incorporate into other computer software, distribute, and sublicense such enhancements or derivative works thereof, in binary and source code form. Copyright Notice ESnet SmartNIC Copyright (c) 2022, The Regents of the University of California, through Lawrence Berkeley National Laboratory (subject to receipt of any required approvals from the U.S. Dept. of Energy), 12574861 Canada Inc., Malleable Networks Inc., and Apical Networks, Inc. All rights reserved. If you have questions about your rights to use or distribute this software, please contact Berkeley Lab's Intellectual Property Office at IPO@lbl.gov. NOTICE. This Software was developed under funding from the U.S. Department of Energy and the U.S. Government consequently retains certain rights. As such, the U.S. Government has been granted for itself and others acting on its behalf a paid-up, nonexclusive, irrevocable, worldwide license in the Software to reproduce, distribute copies to the public, prepare derivative works, and perform publicly and display publicly, and to permit others to do so.","title":"License Agreement"},{"location":"LICENSE_ESNET/#license-agreement","text":"ESnet SmartNIC Copyright (c) 2022, The Regents of the University of California, through Lawrence Berkeley National Laboratory (subject to receipt of any required approvals from the U.S. Dept. of Energy), 12574861 Canada Inc., Malleable Networks Inc., and Apical Networks, Inc. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: (1) Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. (2) Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. (3) Neither the name of the University of California, Lawrence Berkeley National Laboratory, U.S. Dept. of Energy, 12574861 Canada Inc., Malleable Networks Inc., and Apical Networks, Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. You are under no obligation whatsoever to provide any bug fixes, patches, or upgrades to the features, functionality or performance of the source code (\"Enhancements\") to anyone; however, if you choose to make your Enhancements available either publicly, or directly to Lawrence Berkeley National Laboratory, without imposing a separate written license agreement for such Enhancements, then you hereby grant the following license: a non-exclusive, royalty-free perpetual license to install, use, modify, prepare derivative works, incorporate into other computer software, distribute, and sublicense such enhancements or derivative works thereof, in binary and source code form.","title":"License Agreement"},{"location":"LICENSE_ESNET/#copyright-notice","text":"ESnet SmartNIC Copyright (c) 2022, The Regents of the University of California, through Lawrence Berkeley National Laboratory (subject to receipt of any required approvals from the U.S. Dept. of Energy), 12574861 Canada Inc., Malleable Networks Inc., and Apical Networks, Inc. All rights reserved. If you have questions about your rights to use or distribute this software, please contact Berkeley Lab's Intellectual Property Office at IPO@lbl.gov. NOTICE. This Software was developed under funding from the U.S. Department of Energy and the U.S. Government consequently retains certain rights. As such, the U.S. Government has been granted for itself and others acting on its behalf a paid-up, nonexclusive, irrevocable, worldwide license in the Software to reproduce, distribute copies to the public, prepare derivative works, and perform publicly and display publicly, and to permit others to do so.","title":"Copyright Notice"},{"location":"operator/","text":"Using Xilinx Alveo FPGAs as SmartNICs with ESnet Framework Operator's Guide to Configuring an Alveo Host This guide provides an in-depth walkthrough of the process involved in harnessing the capabilities of Xilinx Alveo FPGAs as SmartNICs within the ESnet Framework. Divided into two core sections, the guide outlines the steps required for both development and deployment phases. Development Phase The development phase is a critical initial step, encompassing the setup of a conducive environment for crafting, testing, and compiling P4 programs. These programs will eventually be transformed into executable artifacts capable of running on Xilinx Alveo FPGAs. 1. Installation and Configuration of the Vivado Runtime Environment To commence, it is imperative to install the AMD (Xilinx) Vivado tool suite, incorporating the VitisNetP4 option. This entails setting the VitisNetP4_Option_VISIBLE environment variable to true before initiating the installation process. Execute the following BASH shell command: export VitisNetP4_Option_VISIBLE=true 2. Configuring the Runtime Environment Execute the settings64.sh script located in the Vivado installation directory to configure the runtime environment effectively: source /tools/Xilinx/Vivado/2023.1/settings64.sh Remember, in this illustration, the Vivado installation directory is situated at /tools/Xilinx/Vivado/2023.1/ . 3. Resolving License Dependencies The XILINXD_LICENSE_FILE environment variable needs proper configuration to facilitate license resolution for the AMD (Xilinx) VitisNetp4 IP core. This can be achieved using a .flexlmrc file in the user's home directory or a dedicated BASH script file (like .bashrc ). Execute the following BASH shell command as an example: export XILINXD_LICENSE_FILE=<filename> Once these steps are completed and you have a valid VitisNetworkingP4 license, your environment will be primed for the development of P4 programs tailored for Xilinx Alveo FPGA cards. Deployment Phase The deployment phase entails transferring the compiled bitfiles onto Xilinx Alveo FPGAs. To accomplish this, follow these sequential steps: 1. Ensuring Compatibility and Environment Ensure that your system operates within a Linux environment, ideally Ubuntu 20.04, for a stable and reproducible deployment. 2. FPGA Connectivity Check Validate that your host system is equipped with at least one Xilinx FPGA (U280, U55C, U250). Confirm this by running the command: lspci -d 10ee This command will display any PCIe-connected FPGAs. 3. Configuring Hugepages Verify that hugepages are appropriately configured by examining the kernel boot command line parameters: cat /proc/cmdline Ensure that the output includes lines similar to: BOOT_IMAGE=/boot/vmlinuz-5.4.0-126-generic root=/dev/mapper/vg0-root ro default_hugepagesz=1G hugepagesz=1G hugepages=32 intel_iommu=on iommu=pt 4. Grub Configuration Edit the /etc/default/grub file to include the following line: GRUB_CMDLINE_LINUX_DEFAULT=\"default_hugepagesz=1G hugepagesz=1G hugepages=32 intel_iommu=on iommu=pt\" Subsequently, execute: sudo update-grub 5. IOMMU Confirmation Verify IOMMU is enabled by examining the log: sudo less /var/log/kern.log 6. JTAG/USB Connection Check Ensure that the FPGA has JTAG/USB connectivity by running: lsusb Confirm the presence of the device labeled \"Future Technology Devices International, Ltd FT232H Single HS USB-UART/FIFO,\" which signifies the JTAG connection to the FPGA. 7. Docker Setup Install Docker along with the docker-compose-plugin and docker-buildx-plugin . Detailed instructions can be found in Docker's official documentation . 8. Post-Installation Configuration Follow the post-installation steps outlined in Docker's documentation to grant non-privileged users the ability to execute Docker commands and to implement optional configurations. Completion and References With the successful completion of these phases, your setup is now ready for operation. Should you need further information, the following documents are accessible from the AMD (Xilinx) Vitis Networking P4 Secure Site (upon granted access): Vitis Networking P4 Installation Guide and Release Notes, UG1307 (v2023.1) May 10, 2023 . Vitis Networking P4 User Guide, UG1308 (v2023.1) May 16, 2023 . Vitis Networking P4 Getting Started Guide, UG1373 (v2023.1) May 16, 2023 . Additionally, you may find valuable resources at https://p4.org/ . Known Issues As of now, no known issues have been reported. Your experience should be seamless.","title":"Using Xilinx Alveo FPGAs as SmartNICs with ESnet Framework"},{"location":"operator/#using-xilinx-alveo-fpgas-as-smartnics-with-esnet-framework","text":"","title":"Using Xilinx Alveo FPGAs as SmartNICs with ESnet Framework"},{"location":"operator/#operators-guide-to-configuring-an-alveo-host","text":"This guide provides an in-depth walkthrough of the process involved in harnessing the capabilities of Xilinx Alveo FPGAs as SmartNICs within the ESnet Framework. Divided into two core sections, the guide outlines the steps required for both development and deployment phases.","title":"Operator's Guide to Configuring an Alveo Host"},{"location":"operator/#development-phase","text":"The development phase is a critical initial step, encompassing the setup of a conducive environment for crafting, testing, and compiling P4 programs. These programs will eventually be transformed into executable artifacts capable of running on Xilinx Alveo FPGAs. 1. Installation and Configuration of the Vivado Runtime Environment To commence, it is imperative to install the AMD (Xilinx) Vivado tool suite, incorporating the VitisNetP4 option. This entails setting the VitisNetP4_Option_VISIBLE environment variable to true before initiating the installation process. Execute the following BASH shell command: export VitisNetP4_Option_VISIBLE=true 2. Configuring the Runtime Environment Execute the settings64.sh script located in the Vivado installation directory to configure the runtime environment effectively: source /tools/Xilinx/Vivado/2023.1/settings64.sh Remember, in this illustration, the Vivado installation directory is situated at /tools/Xilinx/Vivado/2023.1/ . 3. Resolving License Dependencies The XILINXD_LICENSE_FILE environment variable needs proper configuration to facilitate license resolution for the AMD (Xilinx) VitisNetp4 IP core. This can be achieved using a .flexlmrc file in the user's home directory or a dedicated BASH script file (like .bashrc ). Execute the following BASH shell command as an example: export XILINXD_LICENSE_FILE=<filename> Once these steps are completed and you have a valid VitisNetworkingP4 license, your environment will be primed for the development of P4 programs tailored for Xilinx Alveo FPGA cards.","title":"Development Phase"},{"location":"operator/#deployment-phase","text":"The deployment phase entails transferring the compiled bitfiles onto Xilinx Alveo FPGAs. To accomplish this, follow these sequential steps: 1. Ensuring Compatibility and Environment Ensure that your system operates within a Linux environment, ideally Ubuntu 20.04, for a stable and reproducible deployment. 2. FPGA Connectivity Check Validate that your host system is equipped with at least one Xilinx FPGA (U280, U55C, U250). Confirm this by running the command: lspci -d 10ee This command will display any PCIe-connected FPGAs. 3. Configuring Hugepages Verify that hugepages are appropriately configured by examining the kernel boot command line parameters: cat /proc/cmdline Ensure that the output includes lines similar to: BOOT_IMAGE=/boot/vmlinuz-5.4.0-126-generic root=/dev/mapper/vg0-root ro default_hugepagesz=1G hugepagesz=1G hugepages=32 intel_iommu=on iommu=pt 4. Grub Configuration Edit the /etc/default/grub file to include the following line: GRUB_CMDLINE_LINUX_DEFAULT=\"default_hugepagesz=1G hugepagesz=1G hugepages=32 intel_iommu=on iommu=pt\" Subsequently, execute: sudo update-grub 5. IOMMU Confirmation Verify IOMMU is enabled by examining the log: sudo less /var/log/kern.log 6. JTAG/USB Connection Check Ensure that the FPGA has JTAG/USB connectivity by running: lsusb Confirm the presence of the device labeled \"Future Technology Devices International, Ltd FT232H Single HS USB-UART/FIFO,\" which signifies the JTAG connection to the FPGA. 7. Docker Setup Install Docker along with the docker-compose-plugin and docker-buildx-plugin . Detailed instructions can be found in Docker's official documentation . 8. Post-Installation Configuration Follow the post-installation steps outlined in Docker's documentation to grant non-privileged users the ability to execute Docker commands and to implement optional configurations.","title":"Deployment Phase"},{"location":"operator/#completion-and-references","text":"With the successful completion of these phases, your setup is now ready for operation. Should you need further information, the following documents are accessible from the AMD (Xilinx) Vitis Networking P4 Secure Site (upon granted access): Vitis Networking P4 Installation Guide and Release Notes, UG1307 (v2023.1) May 10, 2023 . Vitis Networking P4 User Guide, UG1308 (v2023.1) May 16, 2023 . Vitis Networking P4 Getting Started Guide, UG1373 (v2023.1) May 16, 2023 . Additionally, you may find valuable resources at https://p4.org/ .","title":"Completion and References"},{"location":"operator/#known-issues","text":"As of now, no known issues have been reported. Your experience should be seamless.","title":"Known Issues"}]}